---
phase: 27-apps-first-home-schema-alignment
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/brand-scraper/types.ts
  - src/components/admin/brand-scraper/BrandResultsGallery.tsx
  - src/components/admin/brand-scraper/ColorPaletteCard.tsx
  - src/components/admin/brand-scraper/TypographyCard.tsx
  - src/components/admin/brand-scraper/LogoAssetsCard.tsx
  - src/components/tools/brand-scraper/UserBrandScraperPage.tsx
autonomous: true

must_haves:
  truths:
    - "Zod schemas parse real scraper service responses without validation errors"
    - "Color palette card reads hex from entry.value.hex and confidence from entry.confidence"
    - "Typography card reads family from entry.value.family and confidence from entry.confidence"
    - "Logo/assets card reads url from entry.value.url and confidence from entry.confidence"
    - "When result fails Zod parsing, a fallback message appears with a Download Brand JSON link"
    - "Brand results gallery passes data using corrected taxonomy paths (result.color, result.typography, result.assets)"
  artifacts:
    - path: "src/lib/brand-scraper/types.ts"
      provides: "Aligned Zod schemas matching real scraper taxonomy with ExtractedField wrapper"
      contains: "extractedField"
    - path: "src/components/admin/brand-scraper/BrandResultsGallery.tsx"
      provides: "Gallery component using corrected taxonomy paths"
      contains: "result.color"
    - path: "src/components/admin/brand-scraper/ColorPaletteCard.tsx"
      provides: "Color card reading from ExtractedField wrapper"
      contains: "entry.value.hex"
    - path: "src/components/admin/brand-scraper/TypographyCard.tsx"
      provides: "Typography card reading from ExtractedField wrapper"
      contains: "entry.value.family"
    - path: "src/components/admin/brand-scraper/LogoAssetsCard.tsx"
      provides: "Logo/assets card reading from ExtractedField wrapper"
      contains: "entry.value.url"
    - path: "src/components/tools/brand-scraper/UserBrandScraperPage.tsx"
      provides: "Defensive parsing with fallback UI and download link"
      contains: "safeParse"
  key_links:
    - from: "src/components/admin/brand-scraper/BrandResultsGallery.tsx"
      to: "src/lib/brand-scraper/types.ts"
      via: "BrandTaxonomy type import"
      pattern: "BrandTaxonomy"
    - from: "src/components/admin/brand-scraper/ColorPaletteCard.tsx"
      to: "src/lib/brand-scraper/types.ts"
      via: "BrandTaxonomy type for color.palette"
      pattern: 'BrandTaxonomy\["color"\]'
    - from: "src/components/tools/brand-scraper/UserBrandScraperPage.tsx"
      to: "src/lib/brand-scraper/types.ts"
      via: "brandTaxonomySchema.safeParse for defensive parsing"
      pattern: "brandTaxonomySchema.*safeParse"
---

<objective>
Rewrite the Brand Scraper Zod schemas to match the real scraper service taxonomy, update all UI components to read from the corrected nested paths, and add defensive Zod parsing with a fallback UI when data cannot be displayed.

Purpose: The current schemas are wrong (flat structure with `colors`, `fonts`, `logos`) while the real scraper returns a nested taxonomy with `ExtractedField<T>` wrappers (`color.palette[].value.hex`, `typography.font_families[].value.family`, `assets.logos[].value.url`). Without this fix, Brand Scraper results display nothing or throw validation errors.
Output: Corrected Zod schemas, updated gallery components reading from real taxonomy paths, and defensive fallback UI for unexpected data.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/27-apps-first-home-schema-alignment/27-RESEARCH.md

@src/lib/brand-scraper/types.ts
@src/components/admin/brand-scraper/BrandResultsGallery.tsx
@src/components/admin/brand-scraper/ColorPaletteCard.tsx
@src/components/admin/brand-scraper/TypographyCard.tsx
@src/components/admin/brand-scraper/LogoAssetsCard.tsx
@src/components/tools/brand-scraper/UserBrandScraperPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite Zod schemas to match real scraper taxonomy</name>
  <files>src/lib/brand-scraper/types.ts</files>
  <action>
    Completely rewrite the `brandTaxonomySchema` and `jobStatusSchema` in `src/lib/brand-scraper/types.ts`. Keep the `scrapeRequestSchema` and `scrapeJobSubmissionSchema` unchanged (they are correct).

    **brandTaxonomySchema rewrite:**

    The real scraper wraps every extracted item in an `ExtractedField` envelope with `{ value, confidence, evidence, needs_review }`. Build the schema bottom-up:

    1. Create `evidenceSchema`:
       ```typescript
       const evidenceSchema = z.object({
         source_url: z.string(),
         selector: z.string().optional(),
         css_rule: z.string().optional(),
         method: z.string(),
       }).passthrough();
       ```

    2. Create a generic `extractedFieldSchema<T>` helper function:
       ```typescript
       function extractedFieldSchema<T extends z.ZodType>(valueSchema: T) {
         return z.object({
           value: valueSchema,
           confidence: z.number(),
           evidence: z.array(evidenceSchema),
           needs_review: z.boolean(),
         }).passthrough();
       }
       ```

    3. Create value schemas for each data type:
       - `colorPaletteEntrySchema`: `{ hex: string, rgb: { r, g, b }, role?: string, frequency?: number }` with `.passthrough()`
       - `typographyEntrySchema`: `{ family: string, weight: string, size?: string, line_height?: string, usage?: string, source?: string }` with `.passthrough()`. NOTE: `weight` is a single `string` (e.g. "400"), NOT `weights: number[]` like the old schema.
       - `assetEntrySchema`: `{ url: string, local_path?: string, type: string, format?: string, sizes?: string, score?: number, downloaded?: boolean }` with `.passthrough()`

    4. Create the top-level `brandTaxonomySchema`:
       ```typescript
       export const brandTaxonomySchema = z.object({
         brand_id: z.string(),
         source: z.object({
           site_url: z.string(),
           timestamp: z.string(),
           pages_sampled: z.number(),
         }).passthrough(),
         color: z.object({
           palette: z.array(extractedFieldSchema(colorPaletteEntrySchema)),
           tokens_detected: z.boolean(),
         }).optional(),
         typography: z.object({
           font_families: z.array(extractedFieldSchema(typographyEntrySchema)),
           type_scale: z.record(z.string(), z.unknown()).optional(),
         }).optional(),
         assets: z.object({
           logos: z.array(extractedFieldSchema(assetEntrySchema)).optional(),
           favicons: z.array(extractedFieldSchema(assetEntrySchema)).optional(),
           og_images: z.array(extractedFieldSchema(assetEntrySchema)).optional(),
         }).optional(),
         design_tokens: z.object({
           tokens: z.array(z.unknown()),
           source_count: z.number(),
         }).optional(),
         identity: z.object({
           tagline: z.string().optional(),
           industry_guess: z.string().optional(),
         }).optional(),
         governance: z.object({
           robots_respected: z.boolean().optional(),
           license_hints: z.array(z.string()).optional(),
         }).optional(),
         meta: z.object({
           extraction_version: z.string(),
           stages_completed: z.array(z.string()),
           stages_failed: z.array(z.string()),
           errors: z.array(z.object({
             code: z.string(),
             message: z.string(),
             stage: z.string(),
           })),
           summary: z.object({
             fields_populated: z.number(),
             low_confidence_count: z.number(),
             duration_ms: z.number(),
           }),
         }).passthrough(),
       }).passthrough();
       ```

    5. Export the `BrandTaxonomy` type as before: `export type BrandTaxonomy = z.infer<typeof brandTaxonomySchema>;`

    **jobStatusSchema update:**
    Update the `error` field from `z.string().nullish()` to an optional object matching the real API response:
    ```typescript
    export const jobStatusSchema = z.object({
      job_id: z.string(),
      status: z.string(),
      result: brandTaxonomySchema.nullish(),
      error: z.object({
        code: z.string(),
        message: z.string(),
        stage: z.string(),
      }).nullish(),
      brand_json_url: z.string().nullish(),
      assets_zip_url: z.string().nullish(),
    }).passthrough();
    ```

    Also export the `extractedFieldSchema` helper so it can be used by type inference in components if needed:
    ```typescript
    export type ExtractedField<T> = { value: T; confidence: number; evidence: unknown[]; needs_review: boolean };
    ```

    **IMPORTANT**: Use `.passthrough()` generously on ALL object schemas. The real taxonomy has optional sections and may include extra fields. Being too strict here will cause valid responses to be rejected (see research pitfall #3).
  </action>
  <verify>
    Run `npx tsc --noEmit` -- must compile without errors.
    The old `BrandTaxonomy["colors"]`, `BrandTaxonomy["fonts"]`, `BrandTaxonomy["logos"]` paths should no longer exist as types (they will cause compile errors in components that reference them, which is expected and will be fixed in Task 2).
  </verify>
  <done>
    brandTaxonomySchema matches the real scraper service taxonomy with ExtractedField wrappers. jobStatusSchema error field is an object (not string). All schemas use .passthrough() for tolerance. Type compiles successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update gallery components and add defensive parsing</name>
  <files>
    src/components/admin/brand-scraper/BrandResultsGallery.tsx
    src/components/admin/brand-scraper/ColorPaletteCard.tsx
    src/components/admin/brand-scraper/TypographyCard.tsx
    src/components/admin/brand-scraper/LogoAssetsCard.tsx
    src/components/tools/brand-scraper/UserBrandScraperPage.tsx
  </files>
  <action>
    **1. Update `ColorPaletteCard.tsx`:**
    - Change prop type from `colors: BrandTaxonomy["colors"]` to `palette: BrandTaxonomy["color"]` (the entire optional color section).
    - Update the component to handle the new shape:
      - Guard: `if (!palette || palette.palette.length === 0)` return "No colors detected."
      - Map over `palette.palette` (the array of ExtractedField entries).
      - Access data through the wrapper: `entry.value.hex` instead of `color.hex`, `entry.confidence` instead of `color.confidence`, `entry.value.role` instead of `color.name` (the real schema uses `role` not `name`).
      - Update the `key` prop to `entry.value.hex`.
      - Update `handleCopy` to use `entry.value.hex`.
      - Update the display name to show `entry.value.role` (optional) instead of `color.name`.
      - Update `BrandConfidenceBadge` score to `entry.confidence`.

    **2. Update `TypographyCard.tsx`:**
    - Change prop type from `fonts: BrandTaxonomy["fonts"]` to `typography: BrandTaxonomy["typography"]` (the entire optional typography section).
    - Guard: `if (!typography || typography.font_families.length === 0)` return "No fonts detected."
    - Map over `typography.font_families` (array of ExtractedField entries).
    - Access: `entry.value.family` instead of `font.family`, `entry.value.weight` (single string) instead of `font.weights` (was array), `entry.value.usage` instead of `font.usage`, `entry.value.source` instead of `font.source`, `entry.confidence` instead of `font.confidence`.
    - For weights display, show `entry.value.weight` as a single value (e.g., "Weight: 400") instead of joining an array.
    - Key prop: `entry.value.family`.
    - Google Fonts link: check `entry.value.source === "google_fonts"`.

    **3. Update `LogoAssetsCard.tsx`:**
    - Change prop type from `{ logos: BrandTaxonomy["logos"]; assets: BrandTaxonomy["assets"] }` to `{ assets: BrandTaxonomy["assets"] }` (the entire optional assets section, which contains logos, favicons, and og_images).
    - Guard: `if (!assets)` return "No logos or assets detected."
    - Logos section: map over `assets.logos ?? []`. Access `entry.value.url` instead of `logo.url`, `entry.value.format` instead of `logo.format`, `entry.confidence` instead of `logo.confidence`. Key: `entry.value.url`.
    - Favicons section: new section rendering `assets.favicons ?? []` with similar pattern.
    - OG Images section: new section rendering `assets.og_images ?? []` with similar pattern.
    - Remove the old flat `assets` iteration (was `assets.map(asset => ...)`) -- assets are now sub-categorized.

    **4. Update `BrandResultsGallery.tsx`:**
    - Update prop passing to match new component signatures:
      - `<ColorPaletteCard palette={result.color} />` instead of `colors={result.colors}`
      - `<TypographyCard typography={result.typography} />` instead of `fonts={result.fonts}`
      - `<LogoAssetsCard assets={result.assets} />` instead of `logos={result.logos} assets={result.assets}`

    **5. Add defensive parsing in `UserBrandScraperPage.tsx`:**
    - Import `brandTaxonomySchema` from `@/lib/brand-scraper/types`.
    - In the JSX where `data.result` is checked and `BrandResultsGallery` is rendered (around line 199-208), add defensive Zod parsing:
      ```tsx
      {(data?.status === "succeeded" || data?.status === "partial") && data.result && (
        <div className="mt-6">
          {(() => {
            const parsed = brandTaxonomySchema.safeParse(data.result);
            if (!parsed.success) {
              return (
                <div className="rounded-xl border border-amber-200 bg-amber-50 p-6 text-sm">
                  <p className="font-medium text-amber-800 mb-2">
                    We extracted brand data but couldn't display it.
                  </p>
                  <p className="text-amber-700 mb-4">
                    The data format was unexpected. You can still download the raw results.
                  </p>
                  {data.brand_json_url && (
                    <a
                      href={data.brand_json_url}
                      download
                      className="inline-flex items-center gap-2 text-primary hover:text-primary-hover font-medium underline"
                    >
                      Download Brand JSON
                    </a>
                  )}
                </div>
              );
            }
            return (
              <BrandResultsGallery
                result={parsed.data}
                brandJsonUrl={data.brand_json_url ?? undefined}
                assetsZipUrl={data.assets_zip_url ?? undefined}
              />
            );
          })()}
        </div>
      )}
      ```
    - Also update the `data.error` display (around line 210-216) to handle the new error shape (object with `message` field instead of plain string):
      ```tsx
      {data?.status === "failed" && data.error && (
        <div className="mt-4 text-sm">
          <p className="text-red-600">
            {typeof data.error === "string" ? data.error : data.error.message}
          </p>
          <p className="text-text-secondary mt-1">
            Credits have been automatically refunded.
          </p>
        </div>
      )}
      ```

    **CRITICAL**: Every property access on ExtractedField items must go through `.value.` -- this is the most common source of silent `undefined` rendering. Double-check every `entry.value.hex`, `entry.value.family`, `entry.value.url`, etc.
  </action>
  <verify>
    Run `npm run build` -- must succeed with zero errors.
    Run `npm run lint` -- must pass.
    Run `npm run test` -- must pass.
    Grep for `result.colors` in src/components -- should find zero hits (old path).
    Grep for `result.fonts` in src/components -- should find zero hits (old path).
    Grep for `color.hex` in ColorPaletteCard.tsx -- should find zero hits (old path; should be `entry.value.hex`).
    Grep for `font.family` in TypographyCard.tsx -- should find zero hits (old path; should be `entry.value.family`).
    Grep for `logo.url` in LogoAssetsCard.tsx -- should find zero hits (old path; should be `entry.value.url`).
  </verify>
  <done>
    All four gallery components read from corrected nested taxonomy paths using the ExtractedField wrapper pattern. BrandResultsGallery passes data via the correct prop names. UserBrandScraperPage uses safeParse with a fallback UI showing "Download Brand JSON" when parsing fails. Error display handles both string and object error shapes. Build, lint, and tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. `npm run lint` passes with zero errors
3. `npm run test` passes
4. `brandTaxonomySchema` uses `extractedFieldSchema` wrapper pattern
5. `brandTaxonomySchema` has top-level keys: `brand_id`, `source`, `color`, `typography`, `assets`, `meta` (not `colors`, `fonts`, `logos`)
6. ColorPaletteCard reads `entry.value.hex` and `entry.confidence`
7. TypographyCard reads `entry.value.family` and `entry.confidence`
8. LogoAssetsCard reads `entry.value.url` and `entry.confidence`
9. BrandResultsGallery passes `result.color`, `result.typography`, `result.assets` (not `result.colors`, `result.fonts`, `result.logos`)
10. UserBrandScraperPage uses `brandTaxonomySchema.safeParse()` with fallback UI containing "Download Brand JSON" link
11. No references to old flat schema paths (`colors`, `fonts`, `logos` at top level) remain in gallery components
</verification>

<success_criteria>
- Requirements SCHM-01, SCHM-02, SCHM-03 are satisfied
- Zod schemas match the real scraper service taxonomy structure
- UI components read from corrected nested paths via ExtractedField wrappers
- Fallback UI with "Download Brand JSON" link appears when parsing fails
- Build succeeds, lint and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/27-apps-first-home-schema-alignment/27-03-SUMMARY.md`
</output>
