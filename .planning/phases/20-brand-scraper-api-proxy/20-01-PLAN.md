---
phase: 20-brand-scraper-api-proxy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/brand-scraper/types.ts
  - src/lib/brand-scraper/client.ts
  - src/app/api/admin/brand-scraper/scrape/route.ts
  - src/app/api/admin/brand-scraper/jobs/[id]/route.ts
  - .env.local.example
autonomous: true

must_haves:
  truths:
    - "POST /api/admin/brand-scraper/scrape accepts a URL and returns a job ID from the Fastify service"
    - "GET /api/admin/brand-scraper/jobs/[id] returns typed job status with result data when complete"
    - "Both API routes reject unauthenticated requests with 401/403"
    - "Invalid external service responses produce clear 502 errors, not unhandled exceptions"
    - "BRAND_SCRAPER_API_URL is never exposed to the client"
  artifacts:
    - path: "src/lib/brand-scraper/types.ts"
      provides: "Zod schemas and TypeScript types for brand scraper API"
      exports: ["scrapeRequestSchema", "scrapeJobSubmissionSchema", "jobStatusSchema", "ScrapeRequest", "ScrapeJobSubmission", "JobStatus"]
    - path: "src/lib/brand-scraper/client.ts"
      provides: "Typed HTTP client with BrandScraperError class"
      exports: ["BrandScraperError", "submitScrapeJob", "getScrapeJobStatus"]
    - path: "src/app/api/admin/brand-scraper/scrape/route.ts"
      provides: "POST handler for scrape job submission"
      exports: ["POST"]
    - path: "src/app/api/admin/brand-scraper/jobs/[id]/route.ts"
      provides: "GET handler for job status polling"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/admin/brand-scraper/scrape/route.ts"
      to: "src/lib/brand-scraper/client.ts"
      via: "import submitScrapeJob"
      pattern: "submitScrapeJob"
    - from: "src/app/api/admin/brand-scraper/jobs/[id]/route.ts"
      to: "src/lib/brand-scraper/client.ts"
      via: "import getScrapeJobStatus"
      pattern: "getScrapeJobStatus"
    - from: "src/app/api/admin/brand-scraper/scrape/route.ts"
      to: "src/lib/auth/admin.ts"
      via: "import verifyAdmin"
      pattern: "verifyAdmin\\(request\\)"
    - from: "src/app/api/admin/brand-scraper/jobs/[id]/route.ts"
      to: "src/lib/auth/admin.ts"
      via: "import verifyAdmin"
      pattern: "verifyAdmin\\(request\\)"
    - from: "src/lib/brand-scraper/client.ts"
      to: "src/lib/brand-scraper/types.ts"
      via: "import schemas for safeParse"
      pattern: "import.*from.*types"
---

<objective>
Create the typed HTTP client and API route proxies for the Brand Scraper Fastify service.

Purpose: Phase 21 (Brand Scraper UI) needs server-side API routes to submit scrape jobs and poll for results. This phase builds that plumbing -- a typed client with Zod validation and two admin-authenticated API routes -- mirroring the existing chatbot proxy pattern exactly.

Output: Two API routes (POST scrape, GET poll), a typed client module, Zod schemas, and env var documentation.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-brand-scraper-api-proxy/20-RESEARCH.md

# Existing patterns to mirror
@src/lib/assistant/fastapi-client.ts
@src/lib/schemas/fastapi.ts
@src/lib/auth/admin.ts
@src/app/api/assistant/chat/route.ts
@.env.local.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Brand scraper Zod schemas and typed HTTP client</name>
  <files>src/lib/brand-scraper/types.ts, src/lib/brand-scraper/client.ts</files>
  <action>
Create `src/lib/brand-scraper/types.ts` with Zod schemas:

1. `scrapeRequestSchema` -- validates the incoming request body from the frontend:
   - `url`: `z.string().url()` (the URL to scrape)

2. `scrapeJobSubmissionSchema` -- validates the Fastify POST /scrape response:
   - `job_id`: `z.string()`
   - `status`: `z.string()` (use z.string() not z.enum() -- the exact values are not confirmed per research open questions)

3. `jobStatusSchema` -- validates the Fastify GET /jobs/:id response:
   - `job_id`: `z.string()`
   - `status`: `z.string()` (will be tightened to z.enum() in Phase 21 after confirming actual values)
   - `result`: `z.unknown().optional()` (BrandTaxonomy when succeeded -- schema tightened in Phase 21)
   - `error`: `z.string().optional()` (error message when failed)
   - `brand_json_url`: `z.string().optional()` (GCS signed URL for download)
   - `assets_zip_url`: `z.string().optional()` (GCS signed URL for download)

Use `.passthrough()` on `jobStatusSchema` to avoid breaking on unexpected extra fields from the Fastify service.

Export inferred TypeScript types for all schemas: `ScrapeRequest`, `ScrapeJobSubmission`, `JobStatus`.

Create `src/lib/brand-scraper/client.ts` mirroring `src/lib/assistant/fastapi-client.ts`:

1. Read `BRAND_SCRAPER_API_URL` from `process.env` at module scope (NOT `NEXT_PUBLIC_`).

2. `BrandScraperError` class extending Error with `status: number` and `isTimeout: boolean` properties. Mirror `FastApiError` exactly.

3. `submitScrapeJob(url: string): Promise<ScrapeJobSubmission>`:
   - Guard: throw BrandScraperError(503) if BRAND_SCRAPER_API_URL not configured
   - POST to `${BRAND_SCRAPER_API_URL}/scrape` with body `{ site_url: url }` (use `site_url` field name per ARCHITECTURE.md; the exact name is an open question but this is our best guess)
   - Use `AbortSignal.timeout(30_000)` (30 seconds -- longer than chatbot's 15s because of Cloud Run cold starts per research pitfall 4)
   - On non-200: attempt to read response body as JSON and extract `error` field for a better error message. Fall back to generic `Brand scraper returned ${res.status}` if body is not JSON or lacks error field (addresses research pitfall 5)
   - Validate with `scrapeJobSubmissionSchema.safeParse()`, throw BrandScraperError(502) on parse failure
   - Return parsed data

4. `getScrapeJobStatus(jobId: string): Promise<JobStatus>`:
   - Guard: throw BrandScraperError(503) if BRAND_SCRAPER_API_URL not configured
   - GET to `${BRAND_SCRAPER_API_URL}/jobs/${jobId}`
   - Use `AbortSignal.timeout(10_000)` (10 seconds -- shorter than submit, this is a lightweight status check)
   - Same error handling pattern as submitScrapeJob (read error body on non-200)
   - Validate with `jobStatusSchema.safeParse()`, throw BrandScraperError(502) on parse failure
   - Return parsed data

Import Zod schemas from `@/lib/brand-scraper/types`. Follow the exact code structure of `fastapi-client.ts` -- same try/catch pattern, same DOMException timeout detection, same error class shape.
  </action>
  <verify>
Run `npx tsc --noEmit` -- both files compile with no type errors. Manually verify: types.ts exports 3 schemas + 3 types, client.ts exports BrandScraperError + 2 functions.
  </verify>
  <done>
types.ts has 3 Zod schemas (scrapeRequestSchema, scrapeJobSubmissionSchema, jobStatusSchema) with exported TypeScript types. client.ts has BrandScraperError class, submitScrapeJob (30s timeout), and getScrapeJobStatus (10s timeout), both with Zod validation and error body extraction.
  </done>
</task>

<task type="auto">
  <name>Task 2: API route handlers and env var documentation</name>
  <files>src/app/api/admin/brand-scraper/scrape/route.ts, src/app/api/admin/brand-scraper/jobs/[id]/route.ts, .env.local.example</files>
  <action>
Create `src/app/api/admin/brand-scraper/scrape/route.ts`:

1. Add `export const dynamic = "force-dynamic";` at top (same as chatbot route).

2. Export `POST` handler that:
   a. Calls `verifyAdmin(request)` as the FIRST operation. If not authorized, return `unauthorizedResponse(auth)`. Import both from `@/lib/auth/admin`.
   b. Parses request body as JSON. On parse failure, return `Response.json({ error: "Invalid JSON." }, { status: 400 })`.
   c. Validates body with `scrapeRequestSchema.safeParse()`. On validation failure, return 400 with field errors using `parsed.error.flatten().fieldErrors`.
   d. Calls `submitScrapeJob(parsed.data.url)`.
   e. Returns `Response.json(result)` on success (200 with job submission data).
   f. Catches `BrandScraperError`: returns `Response.json({ error: err.message }, { status: err.status >= 500 ? 502 : err.status })`.
   g. Catches unknown errors: returns 500 with generic message.

Create `src/app/api/admin/brand-scraper/jobs/[id]/route.ts`:

1. Add `export const dynamic = "force-dynamic";` at top.

2. Export `GET` handler with Next.js 16 async params signature:
   ```typescript
   export async function GET(
     request: Request,
     { params }: { params: Promise<{ id: string }> },
   ) {
     const { id } = await params;
   ```

3. Same auth pattern as POST route: `verifyAdmin(request)` first, `unauthorizedResponse(auth)` if not authorized.

4. Validate `id` is a non-empty string. Return 400 if empty.

5. Call `getScrapeJobStatus(id)`.

6. Return `Response.json(result)` on success.

7. Same error handling as POST route (BrandScraperError -> mapped status, unknown -> 500).

Update `.env.local.example`:

Add a new section after the "AI Assistant (FastAPI Proxy)" section:

```
# --- Brand Scraper (Fastify Proxy) ---
# URL for the external Brand Scraper Fastify service on Cloud Run
# Local dev: point to your local Fastify instance or deployed Cloud Run service
# Production: set via _BRAND_SCRAPER_API_URL substitution in Cloud Build trigger
BRAND_SCRAPER_API_URL=https://your-brand-scraper-service-url.run.app
```

Follow the exact comment style of the CHATBOT_API_URL section.
  </action>
  <verify>
Run `npx tsc --noEmit` -- all route files compile. Run `npm run lint` -- no Biome errors. Run `npm run build` -- build succeeds with no errors. Verify both route files import `verifyAdmin` and `unauthorizedResponse` from `@/lib/auth/admin`.
  </verify>
  <done>
POST /api/admin/brand-scraper/scrape route validates auth then proxies to Fastify with Zod-validated request/response. GET /api/admin/brand-scraper/jobs/[id] route validates auth then polls job status with async params. Both routes reject unauthenticated requests. .env.local.example documents BRAND_SCRAPER_API_URL.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run lint` passes with zero errors
3. `npm run build` succeeds
4. Both API routes import and call `verifyAdmin` as their first operation
5. Neither route exposes `BRAND_SCRAPER_API_URL` (it only appears in `client.ts` via `process.env`)
6. `client.ts` uses `scrapeJobSubmissionSchema.safeParse()` and `jobStatusSchema.safeParse()` for runtime validation
7. `client.ts` uses 30s timeout for submit and 10s timeout for poll
8. `.env.local.example` contains `BRAND_SCRAPER_API_URL` with descriptive comments
</verification>

<success_criteria>
- POST /api/admin/brand-scraper/scrape: accepts `{ url }`, verifies admin auth, proxies to Fastify, returns `{ job_id, status }`
- GET /api/admin/brand-scraper/jobs/[id]: verifies admin auth, proxies to Fastify, returns typed job status with optional result/URLs
- Both routes return 401/403 for unauthenticated/unauthorized requests
- Zod schemas validate all external API responses; invalid shapes produce 502 with clear error
- Brand scraper code is cleanly separated in `src/lib/brand-scraper/` (no mixing with assistant/chatbot code)
- All quality gates pass: tsc, lint, build
</success_criteria>

<output>
After completion, create `.planning/phases/20-brand-scraper-api-proxy/20-01-SUMMARY.md`
</output>
