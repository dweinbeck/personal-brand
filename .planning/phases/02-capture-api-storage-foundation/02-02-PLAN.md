---
phase: 02-capture-api-storage-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/app/api/gsd/capture/route.ts
autonomous: true
requirements:
  - CAP-DICT
  - CAP-ASYNC

must_haves:
  truths:
    - "POST /api/gsd/capture with valid API key and transcript returns 202 with { status: 'queued', id: '<uuid>' }"
    - "POST /api/gsd/capture without X-API-Key header returns 401"
    - "POST /api/gsd/capture with invalid API key returns 401"
    - "POST /api/gsd/capture with empty transcript returns 400"
    - "POST /api/gsd/capture with transcript over 10,000 chars returns 400"
    - "Capture document is written to Firestore gsd_captures collection with status 'pending'"
    - "Response time is under 5 seconds (no downstream processing blocks the response)"
    - "Error messages are short (<200 chars) for iPhone Shortcuts display"
  artifacts:
    - path: "src/app/api/gsd/capture/route.ts"
      provides: "Dictation capture POST endpoint"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/gsd/capture/route.ts"
      to: "src/lib/auth/api-key.ts"
      via: "import verifyApiKey"
      pattern: "import.*verifyApiKey.*from.*auth/api-key"
    - from: "src/app/api/gsd/capture/route.ts"
      to: "src/lib/gsd/schemas.ts"
      via: "import dictationCaptureSchema"
      pattern: "import.*dictationCaptureSchema.*from.*gsd/schemas"
    - from: "src/app/api/gsd/capture/route.ts"
      to: "src/lib/gsd/capture.ts"
      via: "import saveCapture"
      pattern: "import.*saveCapture.*from.*gsd/capture"
---

<objective>
Create the dictation capture endpoint at POST /api/gsd/capture. This is the primary input path for the iPhone Action Button: the user speaks a request, Shortcuts sends the transcript as JSON, and the endpoint persists it to Firestore and returns 202 Accepted immediately.

Purpose: Enable iPhone Action Button dictation capture with <5s response time. The endpoint writes to Firestore and returns immediately — all downstream processing (LLM routing, GitHub issues, Discord alerts) will be added in Phase 3.

Output: One new route handler file.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-capture-api-storage-foundation/02-RESEARCH.md
@.planning/phases/02-capture-api-storage-foundation/02-01-SUMMARY.md

# Pattern reference
@src/app/api/tools/brand-scraper/scrape/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dictation capture route handler with tests</name>
  <files>
    src/app/api/gsd/capture/route.ts
    src/lib/gsd/__tests__/capture-route.test.ts
  </files>
  <action>
    **1a. Create `src/app/api/gsd/capture/route.ts`:**

    Follow the structure of `src/app/api/tools/brand-scraper/scrape/route.ts`:
    - Auth check first, then validation, then persistence, then async trigger (stub), then response

    Implementation:

    ```typescript
    import { verifyApiKey, apiKeyUnauthorizedResponse } from "@/lib/auth/api-key";
    import { saveCapture } from "@/lib/gsd/capture";
    import { dictationCaptureSchema } from "@/lib/gsd/schemas";

    export async function POST(request: Request) {
      // 1. Auth check
      const auth = verifyApiKey(request);
      if (!auth.authorized) return apiKeyUnauthorizedResponse(auth);

      // 2. Parse body
      let body: unknown;
      try {
        body = await request.json();
      } catch {
        return Response.json({ error: "Invalid JSON." }, { status: 400 });
      }

      // 3. Validate with Zod
      const parsed = dictationCaptureSchema.safeParse(body);
      if (!parsed.success) {
        // Short error message for Shortcuts display (<200 chars)
        const firstIssue = parsed.error.issues[0];
        const message = firstIssue?.message ?? "Invalid request.";
        return Response.json({ error: message }, { status: 400 });
      }

      // 4. Generate capture ID and persist
      const captureId = crypto.randomUUID();
      try {
        await saveCapture({
          id: captureId,
          type: "dictation",
          transcript: parsed.data.transcript,
          context: parsed.data.context,
        });
      } catch (err) {
        console.error("Failed to save capture:", err);
        return Response.json(
          { error: "Failed to save capture." },
          { status: 500 },
        );
      }

      // 5. Async processing placeholder (Phase 3 will add LLM routing here)
      // processCapture(captureId).catch(console.error);

      // 6. Respond immediately with 202 Accepted
      return Response.json(
        { status: "queued", id: captureId },
        { status: 202 },
      );
    }
    ```

    Key decisions:
    - Uses `crypto.randomUUID()` (Node.js built-in, zero dependencies)
    - Returns 202 (not 200 or 201) to signal asynchronous processing
    - Error messages are kept short for Shortcuts alert display
    - The `processCapture` call is commented out as a placeholder for Phase 3
    - No rate limiting beyond API key auth (per Pitfalls research: API key IS the primary gate)

    **1b. Create `src/lib/gsd/__tests__/capture-route.test.ts`:**

    Unit test the route handler. Use Vitest mocks for the auth and persistence modules:

    - Mock `@/lib/auth/api-key` (verifyApiKey, apiKeyUnauthorizedResponse)
    - Mock `@/lib/gsd/capture` (saveCapture)
    - Test cases:
      1. Valid request with transcript and context → 202 with { status: "queued", id }
      2. Valid request with transcript only (no context) → 202
      3. Missing API key → 401 (verifyApiKey returns unauthorized)
      4. Invalid JSON body → 400
      5. Empty transcript → 400 (Zod validation fails)
      6. Transcript too long (>10,000 chars) → 400
      7. Firestore save failure → 500

    Use `new Request("http://localhost/api/gsd/capture", { method: "POST", body: JSON.stringify(...), headers: { "Content-Type": "application/json", "X-API-Key": "test-key" } })` for test requests.

    Mock verifyApiKey to return `{ authorized: true }` for the "test-key" header, and `{ authorized: false, error: "...", status: 401 }` for missing/wrong keys.
  </action>
  <verify>
    1. `npm run build` succeeds (route handler type-checks)
    2. `npm run lint` passes
    3. `npm test -- --run src/lib/gsd/__tests__/capture-route.test.ts` — all 7 test cases pass
    4. `npm test` — all tests pass (no regressions)
  </verify>
  <done>
    - POST /api/gsd/capture route handler created and type-checks
    - All 7 test cases pass covering: valid requests, auth failures, validation failures, persistence failures
    - Response format is { status: "queued", id: "<uuid>" } with HTTP 202
    - Error messages are short strings suitable for Shortcuts display
    - Async processing placeholder is documented with comment for Phase 3
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` — zero errors
2. `npm run build` — zero errors
3. `npm test` — all tests pass including new capture route tests
4. Manual curl test (if dev server running):
   - `curl -X POST http://localhost:3000/api/gsd/capture -H "X-API-Key: $GSD_API_KEY" -H "Content-Type: application/json" -d '{"transcript":"Test capture"}'` returns 202
   - Same without X-API-Key returns 401
</verification>

<success_criteria>
- Route handler exists at src/app/api/gsd/capture/route.ts
- POST returns 202 with { status: "queued", id } for valid requests
- Auth, validation, and persistence errors return appropriate HTTP status codes
- All tests pass
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-capture-api-storage-foundation/02-02-SUMMARY.md`
</output>
