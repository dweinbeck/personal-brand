---
phase: 44-server-side-code-migration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/tasks/auth.ts
  - src/lib/tasks/billing.ts
autonomous: true
requirements: [MIG-05, MIG-06]

must_haves:
  truths:
    - "Firebase Auth token verification in Tasks actions uses the same Firebase Admin SDK instance as existing personal-brand actions"
    - "Tasks billing calls the personal-brand billing API directly via function import, not HTTP"
    - "No duplicate Firebase Admin SDK initialization exists"
    - "No BILLING_API_URL environment variable is referenced by Tasks code"
  artifacts:
    - path: "src/lib/tasks/auth.ts"
      provides: "Tasks-specific verifyUser(idToken) function using shared Firebase Admin"
      exports: ["verifyUser"]
    - path: "src/lib/tasks/billing.ts"
      provides: "Tasks billing adapter using direct function imports"
      exports: ["checkBillingAccess", "billingGuard", "BillingStatus"]
  key_links:
    - from: "src/lib/tasks/auth.ts"
      to: "src/lib/firebase.ts"
      via: "import { auth }"
      pattern: "import.*auth.*from.*@/lib/firebase"
    - from: "src/lib/tasks/billing.ts"
      to: "src/lib/billing/tasks.ts"
      via: "import { checkTasksAccess }"
      pattern: "import.*checkTasksAccess.*from.*@/lib/billing/tasks"
---

<objective>
Create Tasks-specific auth and billing adapter modules that wire into the personal-brand codebase's existing Firebase Admin SDK and billing system.

Purpose: The standalone todoist app had its own `auth.ts` (separate Firebase Admin init) and `billing.ts` (HTTP calls to BILLING_API_URL). These adapters provide the same `verifyUser` and `checkBillingAccess`/`billingGuard` API surface but using direct imports from personal-brand's existing modules -- no duplicate Firebase init, no HTTP calls.
Output: 2 adapter files in `src/lib/tasks/`
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/firebase.ts
@src/lib/auth/user.ts
@src/lib/billing/tasks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Tasks auth adapter using shared Firebase Admin</name>
  <files>src/lib/tasks/auth.ts</files>
  <action>
Create `src/lib/tasks/auth.ts` that provides the same `verifyUser(idToken: string): Promise<string | null>` signature as the todoist `auth.ts`, but uses the personal-brand Firebase Admin SDK singleton instead of initializing its own.

The todoist `verifyUser` did:
1. Check `getApps().length === 0` -> return null
2. Call `getAuth().verifyIdToken(idToken)` -> return `decoded.uid`
3. Catch errors -> return null

The personal-brand equivalent must:
1. Import `{ auth }` from `@/lib/firebase` (the existing Firebase Admin auth instance)
2. If `!auth` -> return null (Firebase not configured)
3. Call `auth.verifyIdToken(idToken)` -> return `decoded.uid`
4. Catch errors -> return null

File content:

```typescript
import "server-only";

import { auth } from "@/lib/firebase";

/**
 * Verifies a Firebase ID token and returns the user's UID.
 * Uses the shared Firebase Admin SDK instance from @/lib/firebase.
 * Compatible with the todoist verifyUser() signature that all Tasks
 * server actions depend on.
 */
export async function verifyUser(idToken: string): Promise<string | null> {
  if (!auth) {
    return null;
  }

  try {
    const decoded = await auth.verifyIdToken(idToken);
    return decoded.uid;
  } catch {
    return null;
  }
}
```

IMPORTANT:
- Do NOT import from `firebase-admin/app` or `firebase-admin/auth` directly -- use the personal-brand `auth` export
- Do NOT import or reference `./firebase-admin` (todoist's side-effect init)
- Include `import "server-only"` at the top (matches todoist pattern, ensures this only runs on server)
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Verify the file imports from `@/lib/firebase` and NOT from `firebase-admin/auth` or `firebase-admin/app`.</verify>
  <done>src/lib/tasks/auth.ts exports verifyUser(idToken) that uses the shared Firebase Admin SDK. No duplicate Firebase initialization.</done>
</task>

<task type="auto">
  <name>Task 2: Create Tasks billing adapter with direct function imports</name>
  <files>src/lib/tasks/billing.ts</files>
  <action>
Create `src/lib/tasks/billing.ts` that provides the same `checkBillingAccess` and `billingGuard` API surface as the todoist `billing.ts`, but calls `checkTasksAccess` from `@/lib/billing/tasks` directly instead of making HTTP calls to `BILLING_API_URL`.

The todoist `checkBillingAccess(idToken)` did:
1. Fetch `${BILLING_API_URL}/api/billing/tasks/access` with Bearer token
2. Return the JSON response as `BillingStatus { mode, reason, weekStart }`
3. On error -> default to `{ mode: "readwrite", weekStart: "" }`

The personal-brand replacement must:
1. Import `{ checkTasksAccess }` from `@/lib/billing/tasks`
2. Verify the user token to get uid and email (import `{ auth }` from `@/lib/firebase`)
3. Call `checkTasksAccess(uid, email)` directly (no HTTP)
4. Return the result in the same `BillingStatus` shape
5. On error -> default to `{ mode: "readwrite", weekStart: "" }` (same graceful degradation)

The `billingGuard` function is a pure function that checks `mode === "readonly"` -- copy it exactly from todoist.

File content:

```typescript
import "server-only";

import { auth } from "@/lib/firebase";
import { checkTasksAccess } from "@/lib/billing/tasks";

export type BillingStatus = {
  mode: "readwrite" | "readonly";
  reason?: "free_week" | "unpaid";
  weekStart: string;
};

/**
 * Checks billing access for Tasks by calling the personal-brand billing
 * module directly (no HTTP call). Takes an idToken, decodes it to get
 * uid/email, then calls checkTasksAccess().
 *
 * Replaces the todoist version that made HTTP calls to BILLING_API_URL.
 */
export async function checkBillingAccess(
  idToken: string,
): Promise<BillingStatus> {
  if (!auth) {
    console.warn("Firebase Auth not available -- defaulting to readwrite");
    return { mode: "readwrite", weekStart: "" };
  }

  try {
    const decoded = await auth.verifyIdToken(idToken);
    const uid = decoded.uid;
    const email = decoded.email ?? "";

    const access = await checkTasksAccess(uid, email);
    return {
      mode: access.mode,
      reason: "reason" in access ? access.reason : undefined,
      weekStart: access.weekStart,
    };
  } catch (e) {
    console.error("Billing check error:", e);
    return { mode: "readwrite", weekStart: "" };
  }
}

/**
 * Guards a server action based on billing status.
 * Returns an error object if the user is in readonly mode, null otherwise.
 * Identical to the todoist version.
 */
export function billingGuard(
  billing: BillingStatus,
): { error: string; code: number } | null {
  if (billing.mode === "readonly") {
    return {
      error: "Insufficient credits. Purchase credits to continue.",
      code: 402,
    };
  }
  return null;
}
```

IMPORTANT:
- Do NOT reference `BILLING_API_URL` or make any HTTP fetch calls
- Do NOT import from todoist paths
- The `checkBillingAccess` function signature must remain `(idToken: string) => Promise<BillingStatus>` to match what all 5 server action files expect
- The `billingGuard` function signature and return type must match the todoist version exactly
- Graceful degradation: if auth fails or billing check fails, default to readwrite (same behavior as todoist)
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Verify the file imports from `@/lib/billing/tasks` and `@/lib/firebase` -- NOT from any external URL or BILLING_API_URL.</verify>
  <done>src/lib/tasks/billing.ts exports checkBillingAccess and billingGuard that call the personal-brand billing system directly via function import. No HTTP calls. Same API surface as todoist version.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `src/lib/tasks/auth.ts` imports `auth` from `@/lib/firebase` (NOT from firebase-admin directly)
3. `src/lib/tasks/billing.ts` imports `checkTasksAccess` from `@/lib/billing/tasks` (NOT BILLING_API_URL)
4. No `fetch()` calls in `src/lib/tasks/billing.ts`
5. No `initializeApp` or `getApps` calls in `src/lib/tasks/auth.ts`
6. Both files include `import "server-only"`
</verification>

<success_criteria>
- verifyUser(idToken) returns uid string using shared Firebase Admin SDK
- checkBillingAccess(idToken) calls checkTasksAccess() directly with no HTTP
- billingGuard checks readonly mode and returns error object or null
- No duplicate Firebase Admin initialization
- No reference to BILLING_API_URL anywhere in new Tasks code
</success_criteria>

<output>
After completion, create `.planning/phases/44-server-side-code-migration/44-02-SUMMARY.md`
</output>
