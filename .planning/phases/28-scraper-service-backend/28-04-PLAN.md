---
phase: 28-scraper-service-backend
plan: 04
type: execute
wave: 3
depends_on: ["28-02", "28-03"]
files_modified:
  - /Users/dweinbeck/Documents/brand-scraper/src/api/routes/jobs.ts
  - /Users/dweinbeck/Documents/brand-scraper/src/api/routes/zip.ts
  - /Users/dweinbeck/Documents/brand-scraper/src/api/server.ts
  - /Users/dweinbeck/Documents/brand-scraper/src/shared/errors.ts

autonomous: true

must_haves:
  truths:
    - "GET /jobs/:id response includes pipeline_meta.events array with progress events"
    - "GET /jobs/:id response includes assets_manifest with signed URLs for each asset"
    - "brand_json_url continues working in GET /jobs/:id response"
    - "POST /jobs/:id/assets/zip creates a zip from GCS objects and returns a signed download URL"
    - "Requesting zip for a job that already has a zip returns a fresh signed URL without recreating"
  artifacts:
    - path: "src/api/routes/jobs.ts"
      provides: "Enriched GET /jobs/:id response with events + assets manifest + signed URLs"
      contains: "assets_manifest"
    - path: "src/api/routes/zip.ts"
      provides: "POST /jobs/:id/assets/zip endpoint for on-demand zip creation"
      exports: ["zipRoutes"]
    - path: "src/api/server.ts"
      provides: "Zip route registered on API server"
      contains: "zipRoutes"
    - path: "src/shared/errors.ts"
      provides: "ZIP_CREATION_FAILED error code"
      contains: "ZIP_CREATION_FAILED"
  key_links:
    - from: "src/api/routes/jobs.ts"
      to: "src/delivery/gcs.ts"
      via: "generateSignedUrl for each asset in manifest"
      pattern: "generateSignedUrl"
    - from: "src/api/routes/zip.ts"
      to: "src/delivery/gcs.ts"
      via: "createOnDemandZip to build and upload zip"
      pattern: "createOnDemandZip"
    - from: "src/api/routes/zip.ts"
      to: "src/db/schema.ts"
      via: "reads assetsManifest, writes gcsAssetsZipUri"
      pattern: "assetsManifest|gcsAssetsZipUri"
    - from: "src/api/server.ts"
      to: "src/api/routes/zip.ts"
      via: "app.register(zipRoutes)"
      pattern: "zipRoutes"
---

<objective>
Extend the GET /jobs/:id response with progress events and signed asset URLs, and create the on-demand zip endpoint.

Purpose: Requirements SAPI-01, PROG-03, ASST-04, and SAPI-03 require the API to return enriched job data and provide zip-on-demand. This is the final plan -- after this, all Phase 28 success criteria are met.

Output: Enriched jobs route, new zip route, registered on API server.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/dweinbeck/Documents/personal-brand/.planning/ROADMAP.md
@/Users/dweinbeck/Documents/personal-brand/.planning/phases/28-scraper-service-backend/28-RESEARCH.md
@/Users/dweinbeck/Documents/personal-brand/.planning/phases/28-scraper-service-backend/28-01-SUMMARY.md
@/Users/dweinbeck/Documents/personal-brand/.planning/phases/28-scraper-service-backend/28-02-SUMMARY.md
@/Users/dweinbeck/Documents/personal-brand/.planning/phases/28-scraper-service-backend/28-03-SUMMARY.md

IMPORTANT: This phase targets the brand-scraper repo at /Users/dweinbeck/Documents/brand-scraper/. All file paths are relative to that repo.

Key source files to read:
@/Users/dweinbeck/Documents/brand-scraper/src/api/routes/jobs.ts
@/Users/dweinbeck/Documents/brand-scraper/src/api/server.ts
@/Users/dweinbeck/Documents/brand-scraper/src/delivery/gcs.ts
@/Users/dweinbeck/Documents/brand-scraper/src/db/schema.ts
@/Users/dweinbeck/Documents/brand-scraper/src/shared/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend GET /jobs/:id with events and assets manifest with signed URLs</name>
  <files>
    /Users/dweinbeck/Documents/brand-scraper/src/api/routes/jobs.ts
  </files>
  <action>
In /Users/dweinbeck/Documents/brand-scraper/src/api/routes/jobs.ts:

1. Update the PipelineMetaSchema to include the events array:
```typescript
const ProgressEventSchema = z.object({
  type: z.string(),
  timestamp: z.string(),
  detail: z.record(z.string(), z.unknown()).optional(),
});

const PipelineMetaSchema = z.object({
  stages: z.array(
    z.object({
      stage: z.string(),
      status: z.string(),
      duration_ms: z.number(),
    }),
  ).optional(),
  pages_sampled: z.number().optional(),
  duration_ms: z.number().optional(),
  events: z.array(ProgressEventSchema).optional(), // NEW
});
```

2. Add an AssetManifestEntrySchema for the response:
```typescript
const AssetManifestEntrySchema = z.object({
  category: z.string(),
  filename: z.string(),
  originalUrl: z.string(),
  contentType: z.string(),
  sizeBytes: z.number(),
  gcsObjectPath: z.string(),
  signed_url: z.string().optional(), // Added at response time
});

const AssetsManifestResponseSchema = z.object({
  assets: z.array(AssetManifestEntrySchema),
  totalCount: z.number(),
  totalSizeBytes: z.number(),
  createdAt: z.string(),
}).nullable();
```

3. Update the JobResponseSchema to include assets_manifest:
```typescript
const JobResponseSchema = z.object({
  job_id: z.string(),
  site_url: z.string(),
  status: z.enum(["queued", "processing", "succeeded", "failed", "partial"]),
  created_at: z.string(),
  started_at: z.string().nullable(),
  completed_at: z.string().nullable(),
  result: z.record(z.string(), z.unknown()).nullable(),
  error: JobErrorSchema.nullable(),
  pipeline_meta: PipelineMetaSchema.nullable(),
  brand_json_url: z.string().nullable(),
  assets_zip_url: z.string().nullable(),
  assets_manifest: AssetsManifestResponseSchema, // NEW
  webhook_status: z.string().nullable(),
});
```

4. In the route handler, after the existing signed URL generation for brand_json_url and assets_zip_url, add signed URL generation for the assets manifest:

```typescript
// Generate signed URLs for assets manifest entries
let assetsManifestResponse = null;
if (gcsBucket && job.assetsManifest) {
  try {
    const expiryMs = Number(process.env.GCS_SIGNED_URL_EXPIRY_MS) || 3_600_000;
    const manifest = job.assetsManifest as import("../../db/schema.js").AssetsManifest;

    // Generate signed URLs for all assets in parallel
    const assetsWithUrls = await Promise.all(
      manifest.assets.map(async (asset) => ({
        ...asset,
        signed_url: await generateSignedUrl(gcsBucket, asset.gcsObjectPath, expiryMs),
      })),
    );

    assetsManifestResponse = {
      assets: assetsWithUrls,
      totalCount: manifest.totalCount,
      totalSizeBytes: manifest.totalSizeBytes,
      createdAt: manifest.createdAt,
    };
  } catch (err) {
    app.log.warn({ error: String(err), jobId: job.id }, "failed to generate asset signed URLs");
    // Return manifest without signed URLs
    assetsManifestResponse = job.assetsManifest as import("../../db/schema.js").AssetsManifest;
  }
}
```

5. Update the return object to include assets_manifest:
```typescript
return {
  job_id: job.id,
  site_url: job.siteUrl,
  status: job.status,
  created_at: job.createdAt.toISOString(),
  started_at: job.startedAt?.toISOString() ?? null,
  completed_at: job.completedAt?.toISOString() ?? null,
  result: job.result ?? null,
  error: job.error ?? null,
  pipeline_meta: job.pipelineMeta ?? null,
  brand_json_url: brandJsonUrl,
  assets_zip_url: assetsZipUrl,
  assets_manifest: assetsManifestResponse, // NEW
  webhook_status: job.webhookStatus ?? null,
};
```

IMPORTANT: The brand_json_url and assets_zip_url fields MUST remain in the response (SAPI-03 regression protection). The existing signed URL generation for these fields must not be changed.

NOTE on performance: For a job with ~20 assets, Promise.all over 20 parallel getSignedUrl calls takes ~100-200ms wall time. This is acceptable for a polling endpoint.
  </action>
  <verify>
1. `cd /Users/dweinbeck/Documents/brand-scraper && npx tsc --noEmit` passes
2. Response schema includes assets_manifest: `grep -n "assets_manifest" /Users/dweinbeck/Documents/brand-scraper/src/api/routes/jobs.ts`
3. Signed URL generation for assets uses Promise.all: `grep -n "Promise.all" /Users/dweinbeck/Documents/brand-scraper/src/api/routes/jobs.ts`
4. brand_json_url still in response: `grep -n "brand_json_url" /Users/dweinbeck/Documents/brand-scraper/src/api/routes/jobs.ts`
  </verify>
  <done>
- GET /jobs/:id returns pipeline_meta with events array (PROG-03)
- GET /jobs/:id returns assets_manifest with signed URLs for each asset (SAPI-01)
- brand_json_url continues working (SAPI-03)
- Signed URLs generated in parallel via Promise.all
  </done>
</task>

<task type="auto">
  <name>Task 2: Create POST /jobs/:id/assets/zip endpoint and register it</name>
  <files>
    /Users/dweinbeck/Documents/brand-scraper/src/api/routes/zip.ts
    /Users/dweinbeck/Documents/brand-scraper/src/api/server.ts
    /Users/dweinbeck/Documents/brand-scraper/src/shared/errors.ts
  </files>
  <action>
**In /Users/dweinbeck/Documents/brand-scraper/src/shared/errors.ts:**

Add a new error code to the ErrorCodes object:
```typescript
ZIP_CREATION_FAILED: "ZIP_CREATION_FAILED",
```

**Create /Users/dweinbeck/Documents/brand-scraper/src/api/routes/zip.ts:**

```typescript
import { eq } from "drizzle-orm";
import type { FastifyInstance } from "fastify";
import { z } from "zod";
import { jobs } from "../../db/schema.js";
import type { AssetsManifest } from "../../db/schema.js";
import { createOnDemandZip, generateSignedUrl } from "../../delivery/gcs.js";

const ZipParamsSchema = z.object({
  id: z.string(),
});

const ZipResponseSchema = z.object({
  zip_url: z.string(),
});

const ZipErrorSchema = z.object({
  error: z.string(),
});

export async function zipRoutes(app: FastifyInstance) {
  app.post(
    "/jobs/:id/assets/zip",
    {
      schema: {
        params: ZipParamsSchema,
        response: {
          200: ZipResponseSchema,
          404: ZipErrorSchema,
          400: ZipErrorSchema,
          500: ZipErrorSchema,
        },
      },
    },
    async (request, reply) => {
      const { id } = request.params as z.infer<typeof ZipParamsSchema>;

      const job = await app.db.query.jobs.findFirst({
        where: eq(jobs.id, id),
      });

      if (!job) {
        return reply.status(404).send({ error: "Job not found" });
      }

      // Only allow zip for completed jobs
      if (job.status !== "succeeded" && job.status !== "partial") {
        return reply.status(400).send({
          error: `Job status is "${job.status}" — zip is only available for succeeded or partial jobs`,
        });
      }

      const gcsBucket = process.env.GCS_BUCKET;
      if (!gcsBucket) {
        return reply.status(500).send({ error: "GCS not configured" });
      }

      // Check if zip already exists — return fresh signed URL without recreating
      if (job.gcsAssetsZipUri) {
        try {
          const expiryMs = Number(process.env.GCS_SIGNED_URL_EXPIRY_MS) || 3_600_000;
          const zipPath = job.gcsAssetsZipUri.replace(`gs://${gcsBucket}/`, "");
          const signedUrl = await generateSignedUrl(gcsBucket, zipPath, expiryMs);
          return { zip_url: signedUrl };
        } catch (err) {
          // Zip URI exists but file may be missing -- fall through to recreate
          app.log.warn({ error: String(err), jobId: id }, "cached zip URL failed, recreating");
        }
      }

      // Get assets manifest
      const manifest = job.assetsManifest as AssetsManifest | null;
      if (!manifest || manifest.assets.length === 0) {
        return reply.status(400).send({ error: "No assets available for this job" });
      }

      try {
        const expiryMs = Number(process.env.GCS_SIGNED_URL_EXPIRY_MS) || 3_600_000;
        const result = await createOnDemandZip(
          gcsBucket,
          id,
          manifest.assets.map((a) => ({
            gcsObjectPath: a.gcsObjectPath,
            category: a.category,
            filename: a.filename,
          })),
          expiryMs,
        );

        // Cache the zip URI in the DB for future requests
        await app.db
          .update(jobs)
          .set({ gcsAssetsZipUri: result.zipUri })
          .where(eq(jobs.id, id));

        app.log.info({ jobId: id, zipUri: result.zipUri }, "on-demand zip created");

        return { zip_url: result.signedUrl };
      } catch (err) {
        app.log.error({ error: String(err), jobId: id }, "zip creation failed");
        return reply.status(500).send({ error: "Failed to create zip file" });
      }
    },
  );
}
```

**In /Users/dweinbeck/Documents/brand-scraper/src/api/server.ts:**

1. Add import for the zip routes:
```typescript
import { zipRoutes } from "./routes/zip.js";
```

2. Register the zip routes alongside the existing routes (after `app.register(jobRoutes)`):
```typescript
app.register(zipRoutes);
```
  </action>
  <verify>
1. `cd /Users/dweinbeck/Documents/brand-scraper && npx tsc --noEmit` passes
2. Zip route file exists: `ls /Users/dweinbeck/Documents/brand-scraper/src/api/routes/zip.ts`
3. Zip route registered: `grep "zipRoutes" /Users/dweinbeck/Documents/brand-scraper/src/api/server.ts`
4. ZIP_CREATION_FAILED error code exists: `grep "ZIP_CREATION_FAILED" /Users/dweinbeck/Documents/brand-scraper/src/shared/errors.ts`
5. `cd /Users/dweinbeck/Documents/brand-scraper && npm test` passes
6. `cd /Users/dweinbeck/Documents/brand-scraper && npm run build` passes
  </verify>
  <done>
- POST /jobs/:id/assets/zip endpoint created
- Returns cached zip signed URL if zip already exists (no recreation)
- Creates zip on demand via createOnDemandZip if no cached zip
- Caches zip URI in gcsAssetsZipUri column for future requests
- Validates job exists, is completed, has manifest
- ZIP_CREATION_FAILED error code added
- Route registered on API server
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd /Users/dweinbeck/Documents/brand-scraper && npx tsc --noEmit`
2. Tests pass: `cd /Users/dweinbeck/Documents/brand-scraper && npm test`
3. Build succeeds: `cd /Users/dweinbeck/Documents/brand-scraper && npm run build`
4. Lint passes: `cd /Users/dweinbeck/Documents/brand-scraper && npm run lint`
5. GET /jobs/:id response schema includes assets_manifest and events in pipeline_meta
6. POST /jobs/:id/assets/zip endpoint registered and returns signed URL
7. brand_json_url continues to work in GET /jobs/:id (no regression)
</verification>

<success_criteria>
All Phase 28 success criteria met:
1. Progress events emitted and persisted in pipelineMeta JSONB during processing (PROG-01, PROG-02)
2. Each asset uploaded individually to GCS (ASST-01)
3. Assets manifest persisted to DB (ASST-02)
4. DB schema has gcsAssetsPrefix and assetsManifest columns (SAPI-02)
5. POST /jobs/:id/assets/zip creates zip and returns signed URL (ASST-04)
6. GET /jobs/:id includes events and assets manifest with signed URLs (SAPI-01, PROG-03)
7. brand_json_url continues working (SAPI-03)
</success_criteria>

<output>
After completion, create `/Users/dweinbeck/Documents/personal-brand/.planning/phases/28-scraper-service-backend/28-04-SUMMARY.md`
</output>
