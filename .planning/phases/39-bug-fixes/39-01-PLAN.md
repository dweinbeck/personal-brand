---
phase: 39-bug-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/tools/brand-scraper/UserBrandScraperPage.tsx
  - src/components/tools/brand-scraper/BrandCard.tsx
  - src/components/tools/brand-scraper/BrandCardDownloads.tsx
  - src/lib/brand-scraper/hooks.ts
  - src/components/admin/brand-scraper/BrandScraperPage.tsx
autonomous: true

must_haves:
  truths:
    - "On /apps/brand-scraper, the Scrape button is disabled until both a valid URL is entered AND the user has sufficient credits"
    - "Authenticated users can scrape a URL without encountering 'invalid or expired token' errors during job polling"
    - "Asset downloads also use fresh tokens, not stale ones from submit time"
  artifacts:
    - path: "src/components/tools/brand-scraper/UserBrandScraperPage.tsx"
      provides: "URL-aware disabled state on Scrape button, getIdToken-based auth"
      contains: "isValidUrl"
    - path: "src/lib/brand-scraper/hooks.ts"
      provides: "Token-refreshing job status polling hook"
      contains: "getIdToken"
    - path: "src/components/tools/brand-scraper/BrandCardDownloads.tsx"
      provides: "Fresh token for zip download API call"
      contains: "getIdToken"
  key_links:
    - from: "src/components/tools/brand-scraper/UserBrandScraperPage.tsx"
      to: "src/lib/brand-scraper/hooks.ts"
      via: "useJobStatus hook with getIdToken callback"
      pattern: "useJobStatus.*getIdToken"
    - from: "src/components/tools/brand-scraper/BrandCardDownloads.tsx"
      to: "getIdToken callback"
      via: "Fresh token fetched before zip download fetch"
      pattern: "getIdToken.*fetch"
---

<objective>
Fix brand scraper bugs BUG-01 and BUG-02: (1) Scrape button does not reactively enable when a valid URL is entered, and (2) job polling and asset downloads fail with "invalid or expired token" because auth tokens captured at submit time are never refreshed.

Purpose: Users on /apps/brand-scraper should see the Scrape button enable as soon as they type a valid URL (with sufficient credits), and all authenticated API calls should use fresh tokens.

Output: Fixed UserBrandScraperPage.tsx, updated useJobStatus hook with token refresh, updated BrandCard/BrandCardDownloads for fresh tokens, and updated admin BrandScraperPage.tsx for consistency.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/components/tools/brand-scraper/UserBrandScraperPage.tsx
@src/components/tools/brand-scraper/BrandCard.tsx
@src/components/tools/brand-scraper/BrandCardDownloads.tsx
@src/lib/brand-scraper/hooks.ts
@src/components/admin/brand-scraper/BrandScraperPage.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Scrape button disabled state to include URL validity check</name>
  <files>src/components/tools/brand-scraper/UserBrandScraperPage.tsx</files>
  <action>
In UserBrandScraperPage.tsx, the Scrape button (line ~238) has `disabled={submitting || !hasEnough}`. The button appears enabled even with an empty URL input -- native HTML5 `required` only prevents form submission but the button visually looks clickable.

Fix: Add URL validity checking to the disabled condition.

1. Add a derived `isValidUrl` variable near the other derived state (around line 76-80):
   ```typescript
   const isValidUrl = (() => {
     if (!url.trim()) return false;
     try {
       const parsed = new URL(url.trim());
       return parsed.protocol === "https:" || parsed.protocol === "http:";
     } catch {
       return false;
     }
   })();
   ```

2. Update the Button disabled prop from:
   `disabled={submitting || !hasEnough}`
   to:
   `disabled={submitting || !hasEnough || !isValidUrl}`

This provides immediate visual feedback as the user types.
  </action>
  <verify>Run `npm run build` to confirm no type errors.</verify>
  <done>The Scrape button is visually disabled when no URL or an invalid URL is entered, and enables immediately when a valid http/https URL is typed (assuming sufficient credits).</done>
</task>

<task type="auto">
  <name>Task 2: Replace static token with getIdToken callback for fresh auth on every request</name>
  <files>src/lib/brand-scraper/hooks.ts, src/components/tools/brand-scraper/UserBrandScraperPage.tsx, src/components/tools/brand-scraper/BrandCard.tsx, src/components/tools/brand-scraper/BrandCardDownloads.tsx, src/components/admin/brand-scraper/BrandScraperPage.tsx</files>
  <action>
The `useJobStatus` hook and `BrandCardDownloads` component use a static token captured at job submission time. If the token expires during long polling or before download, requests fail with "Invalid or expired token."

Fix: Replace static token with a `getIdToken` callback that fetches a fresh Firebase ID token for each request.

**Step 1 -- Update `useJobStatus` hook in `src/lib/brand-scraper/hooks.ts`:**

Change the second parameter from `token: string | null` to `getIdToken: (() => Promise<string>) | null`.

Update the SWR key from `jobId && token ? ...` to `jobId && getIdToken ? ...`.

Update the fetcher to call `getIdToken()` before each request:
```typescript
const fetcher = useCallback(
  async (url: string): Promise<JobStatus> => {
    const freshToken = await getIdToken!();
    const res = await fetch(url, {
      headers: { Authorization: `Bearer ${freshToken}` },
    });
    if (!res.ok) {
      throw new Error(`Job status fetch failed: ${res.status}`);
    }
    return res.json() as Promise<JobStatus>;
  },
  [getIdToken],
);
```

**Step 2 -- Update `UserBrandScraperPage.tsx`:**

- Remove `const [token, setToken] = useState<string | null>(null);`
- Add a stable `getIdToken` callback using `useCallback`:
  ```typescript
  const getIdToken = useCallback(async () => {
    if (!user) throw new Error("Not authenticated");
    return user.getIdToken();
  }, [user]);
  ```
- Change `useJobStatus(jobId, token, API_BASE)` to `useJobStatus(jobId, user ? getIdToken : null, API_BASE)`
- In `handleSubmit`: remove `setToken(idToken)` (the idToken variable used for the initial scrape POST is fine as a local var)
- In `handleNewScrape`: remove `setToken(null)`
- In the initialJobId `useEffect`: simplify to just `setJobId(initialJobId)` -- no need for `user.getIdToken().then(...)` wrapper since the hook handles token refresh
- In `handleViewResults`: simplify to just `setJobId(historyJobId)` -- remove the `getIdToken` call and `setToken`
- Pass `getIdToken` instead of `token` to `BrandCard`:
  ```typescript
  <BrandCard result={parsed.data} brandJsonUrl={data.brand_json_url ?? undefined} jobId={jobId} getIdToken={getIdToken} />
  ```

**Step 3 -- Update `BrandCard.tsx`:**

Change props from `token: string` to `getIdToken: () => Promise<string>`. Pass `getIdToken` through to `BrandCardDownloads` instead of `token`.

**Step 4 -- Update `BrandCardDownloads.tsx`:**

Change props from `token: string` to `getIdToken: () => Promise<string>`.

In `handleZipDownload`, call `const freshToken = await getIdToken();` before the fetch and use `freshToken` in the Authorization header.

Update the `useCallback` dependency array from `[jobId, token]` to `[jobId, getIdToken]`.

**Step 5 -- Update admin `BrandScraperPage.tsx`:**

Apply the same pattern: remove `const [token, setToken] = useState<string | null>(null);`, create `getIdToken` callback, pass to `useJobStatus`. Remove `setToken` calls from `handleJobSubmitted` and `handleNewScrape`.

Run `npm run lint && npm run build` after all changes.
  </action>
  <verify>Run `npm run lint && npm run build` -- zero errors. Grep for `useJobStatus` to confirm all call sites updated. Grep for `setToken` to confirm no stale token state remains in brand scraper components.</verify>
  <done>All brand scraper API calls (polling, downloads) use fresh auth tokens fetched at request time, preventing "invalid or expired token" errors. No static token state remains in brand scraper components.</done>
</task>

</tasks>

<verification>
- `npm run lint` passes with zero errors
- `npm run build` succeeds with zero errors
- `npm test` passes (if applicable tests exist)
- Grep for `useJobStatus` confirms all call sites pass `getIdToken` callback
- Grep for `setToken` confirms no stale token state in brand scraper components
- The Scrape button disabled state includes URL validity check
</verification>

<success_criteria>
1. On /apps/brand-scraper, the Scrape button is disabled until a valid URL is entered AND credits are sufficient
2. Job polling and asset downloads use fresh auth tokens per request, eliminating "invalid or expired token" errors
3. Build, lint, and tests all pass
</success_criteria>

<output>
After completion, create `.planning/phases/39-bug-fixes/39-01-SUMMARY.md`
</output>
