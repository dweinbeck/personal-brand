---
phase: 18-content-editor-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/schemas/content.ts
  - src/lib/auth/admin.ts
  - src/lib/actions/content.ts
autonomous: true

must_haves:
  truths:
    - "saveTutorial rejects calls when NODE_ENV is not 'development' with a clear error"
    - "saveTutorial rejects calls with an invalid or missing Firebase ID token"
    - "saveTutorial rejects slugs with path traversal characters or invalid format"
    - "saveTutorial rejects slugs that already exist as MDX files"
    - "saveTutorial writes a valid MDX file with correct export const metadata format to src/content/building-blocks/"
    - "verifyAdminToken is a shared function usable by both Server Actions and API routes"
  artifacts:
    - path: "src/lib/schemas/content.ts"
      provides: "Zod schemas for tutorial slug, metadata, and save payload"
      exports: ["tutorialSlugSchema", "tutorialMetaSchema", "saveTutorialSchema", "SaveTutorialData"]
    - path: "src/lib/auth/admin.ts"
      provides: "Extracted verifyAdminToken function for token-only verification"
      exports: ["verifyAdminToken", "verifyAdmin", "AdminAuthResult", "unauthorizedResponse"]
    - path: "src/lib/actions/content.ts"
      provides: "saveTutorial Server Action with full validation pipeline"
      exports: ["saveTutorial", "SaveResult"]
  key_links:
    - from: "src/lib/actions/content.ts"
      to: "src/lib/schemas/content.ts"
      via: "import saveTutorialSchema for input validation"
      pattern: "import.*saveTutorialSchema.*from.*schemas/content"
    - from: "src/lib/actions/content.ts"
      to: "src/lib/auth/admin.ts"
      via: "import verifyAdminToken for auth check"
      pattern: "import.*verifyAdminToken.*from.*auth/admin"
    - from: "src/lib/actions/content.ts"
      to: "src/content/building-blocks/"
      via: "fs/promises.writeFile to content directory"
      pattern: "writeFile.*filePath"
---

<objective>
Create the server-side infrastructure for saving new Building Blocks tutorials: Zod validation schemas, a shared admin token verifier, and the saveTutorial Server Action with environment gating, auth, slug safety, and MDX file writing.

Purpose: This is the core CC-02 plumbing -- without it, the content editor UI (Phase 19) has nothing to call.
Output: Three files -- content schema, refactored admin auth, and the save action.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-content-editor-infrastructure/18-RESEARCH.md

Key source files to reference:
@src/lib/schemas/contact.ts (Zod schema pattern)
@src/lib/auth/admin.ts (admin auth pattern -- will be modified)
@src/lib/actions/contact.ts (Server Action pattern)
@src/lib/tutorials.ts (CONTENT_DIR constant, TutorialMeta type)
@src/lib/constants.ts (ADMIN_EMAIL)
@src/content/building-blocks/setting-up-a-repo.mdx (MDX metadata format)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tutorial content Zod schemas</name>
  <files>src/lib/schemas/content.ts</files>
  <action>
Create `src/lib/schemas/content.ts` following the pattern in `src/lib/schemas/contact.ts`.

Define these schemas:

1. `tutorialSlugSchema` -- a Zod string with:
   - `.min(3)` with message "Slug must be at least 3 characters"
   - `.max(100)` with message "Slug must be at most 100 characters"
   - `.regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/)` with message "Slug must contain only lowercase letters, numbers, and hyphens"

2. `tutorialMetaSchema` -- a Zod object with:
   - `title`: string, min 1 ("Title is required"), max 200
   - `description`: string, min 1 ("Description is required"), max 500
   - `publishedAt`: string, regex `/^\d{4}-\d{2}-\d{2}$/` ("Must be YYYY-MM-DD format")
   - `tags`: array of string (each min 1, max 50), min 1 array ("At least one tag required"), max 10

3. `saveTutorialSchema` -- a Zod object with:
   - `slug`: tutorialSlugSchema
   - `metadata`: tutorialMetaSchema
   - `body`: string, min 1 ("Content body is required")

4. Export the `SaveTutorialData` type: `z.infer<typeof saveTutorialSchema>`

Use `import { z } from "zod"` (matching existing project convention).
  </action>
  <verify>Run `npm run build` -- the new schema file must compile without TypeScript errors. Run `npm run lint` -- must pass Biome checks.</verify>
  <done>src/lib/schemas/content.ts exists with tutorialSlugSchema, tutorialMetaSchema, saveTutorialSchema, and SaveTutorialData type exported.</done>
</task>

<task type="auto">
  <name>Task 2: Extract verifyAdminToken from admin.ts</name>
  <files>src/lib/auth/admin.ts</files>
  <action>
Refactor `src/lib/auth/admin.ts` to extract the token verification logic into a reusable function that Server Actions can call (since they don't have a Request object with Authorization header).

Add a new exported function `verifyAdminToken(idToken: string): Promise<boolean>`:
- If `getApps().length === 0`, return `false`
- `try` block: call `getAuth().verifyIdToken(idToken)`, check `decoded.email === ADMIN_EMAIL`, return the boolean result
- `catch` block: return `false`

Then refactor the existing `verifyAdmin(request: Request)` to use `verifyAdminToken` internally:
- Extract the Bearer token from the Authorization header (existing logic)
- Call `verifyAdminToken(idToken)` instead of duplicating the Firebase verification
- If `verifyAdminToken` returns `false`, return the appropriate error result
- If `true`, return `{ authorized: true, email: decoded.email }` -- note: you need the email, so `verifyAdminToken` should NOT be used here directly since it only returns boolean. Instead, keep the internal call to `verifyIdToken` in `verifyAdmin` but extract the Firebase check as `verifyAdminToken` as a standalone function for Server Action use.

**Clarification:** Do NOT change the `verifyAdmin` function's internal implementation. Just ADD the new `verifyAdminToken` function alongside it. Both functions independently call `getAuth().verifyIdToken()`. This avoids breaking existing API routes that use `verifyAdmin`.

The function signature:
```typescript
export async function verifyAdminToken(idToken: string): Promise<boolean> {
  if (getApps().length === 0) return false;
  try {
    const decoded = await getAuth().verifyIdToken(idToken);
    return decoded.email === ADMIN_EMAIL;
  } catch {
    return false;
  }
}
```

Place this function BEFORE the existing `verifyAdmin` function in the file.
  </action>
  <verify>Run `npm run build` -- existing code that imports from `src/lib/auth/admin.ts` must still compile. Run `npm run lint` -- must pass.</verify>
  <done>src/lib/auth/admin.ts exports verifyAdminToken alongside existing verifyAdmin, unauthorizedResponse. No existing behavior changed.</done>
</task>

<task type="auto">
  <name>Task 3: Create saveTutorial Server Action</name>
  <files>src/lib/actions/content.ts</files>
  <action>
Create `src/lib/actions/content.ts` following the Server Action pattern from `src/lib/actions/contact.ts`.

File starts with `"use server";` directive.

Imports:
- `{ existsSync } from "node:fs"`
- `{ writeFile } from "node:fs/promises"`
- `path from "node:path"`
- `{ verifyAdminToken } from "@/lib/auth/admin"`
- `{ saveTutorialSchema, type SaveTutorialData } from "@/lib/schemas/content"`

Constants:
- `const CONTENT_DIR = path.join(process.cwd(), "src", "content", "building-blocks");`

Types:
- Export `SaveResult = { success: true; slug: string } | { success: false; error: string }`

Helper function `buildMdxContent(meta: { title: string; description: string; publishedAt: string; tags: string[] }, body: string): string`:
- Returns a template string matching EXACTLY the format in existing `.mdx` files:
```
export const metadata = {
  title: {JSON.stringify(meta.title)},
  description: {JSON.stringify(meta.description)},
  publishedAt: {JSON.stringify(meta.publishedAt)},
  tags: {JSON.stringify(meta.tags)},
};

{body}
```
- Use `JSON.stringify()` for ALL string and array values to handle special characters safely
- End with a trailing newline

Main exported function `saveTutorial(idToken: string, data: SaveTutorialData): Promise<SaveResult>`:

Execute checks in this EXACT order (each returns early on failure):

1. **Environment gate** (FIRST): `if (process.env.NODE_ENV !== "development")` return `{ success: false, error: "Content editing is only available in development mode." }`

2. **Auth verification**: call `verifyAdminToken(idToken)`. If false, return `{ success: false, error: "Unauthorized." }`

3. **Input validation**: `saveTutorialSchema.safeParse(data)`. If not success, return `{ success: false, error: "Invalid input." }`

4. **Path traversal prevention**: `const filePath = path.resolve(CONTENT_DIR, \`\${parsed.data.slug}.mdx\`);` then check `if (!filePath.startsWith(CONTENT_DIR + path.sep))` return `{ success: false, error: "Invalid slug." }`

5. **Collision check**: `if (existsSync(filePath))` return `{ success: false, error: \`A tutorial with slug "\${parsed.data.slug}" already exists.\` }`

6. **Write file**: `const content = buildMdxContent(parsed.data.metadata, parsed.data.body);` then `await writeFile(filePath, content, "utf-8");`

7. **Return success**: `{ success: true, slug: parsed.data.slug }`

Wrap the writeFile call in a try/catch. On error, return `{ success: false, error: "Failed to write tutorial file." }`.
  </action>
  <verify>Run `npm run build` -- must compile without errors. Run `npm run lint` -- must pass Biome checks. Manually verify the file has "use server" directive, all 5 security checks in the correct order, and the MDX template matches existing files.</verify>
  <done>src/lib/actions/content.ts exports saveTutorial and SaveResult. The action enforces: (1) dev-only environment gate, (2) Firebase admin token auth, (3) Zod schema validation, (4) path traversal prevention, (5) slug collision check. On success, writes a valid MDX file to the building-blocks content directory.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with no errors
2. `npm run build` succeeds with no TypeScript errors
3. `src/lib/schemas/content.ts` exports saveTutorialSchema, tutorialSlugSchema, tutorialMetaSchema, SaveTutorialData
4. `src/lib/auth/admin.ts` exports verifyAdminToken (new) alongside existing exports
5. `src/lib/actions/content.ts` has "use server" directive and exports saveTutorial, SaveResult
6. saveTutorial check order: env gate -> auth -> validation -> path safety -> collision -> write
7. MDX template output matches `export const metadata = { title, description, publishedAt, tags };` format from existing .mdx files
8. No existing imports or behavior broken (grep for imports from auth/admin)
</verification>

<success_criteria>
- Build and lint pass cleanly
- saveTutorial Server Action exists with all 5 security layers
- Zod schemas provide type-safe validation for tutorial metadata and slugs
- verifyAdminToken is available as a shared auth function for Server Actions
- No existing functionality broken
</success_criteria>

<output>
After completion, create `.planning/phases/18-content-editor-infrastructure/18-01-SUMMARY.md`
</output>
