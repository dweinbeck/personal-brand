---
phase: 33-multi-user-auth
plan: 03
type: execute
wave: 3
depends_on: ["33-01", "33-02"]
files_modified:
  - /Users/dweinbeck/Documents/todoist/src/services/workspace.service.ts
  - /Users/dweinbeck/Documents/todoist/src/services/project.service.ts
  - /Users/dweinbeck/Documents/todoist/src/services/section.service.ts
  - /Users/dweinbeck/Documents/todoist/src/services/task.service.ts
  - /Users/dweinbeck/Documents/todoist/src/services/tag.service.ts
  - /Users/dweinbeck/Documents/todoist/src/actions/workspace.ts
  - /Users/dweinbeck/Documents/todoist/src/actions/project.ts
  - /Users/dweinbeck/Documents/todoist/src/actions/section.ts
  - /Users/dweinbeck/Documents/todoist/src/actions/task.ts
  - /Users/dweinbeck/Documents/todoist/src/actions/tag.ts
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/layout.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/page.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/[projectId]/page.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/today/page.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/completed/page.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/search/page.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/tags/page.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/tags/[tagId]/page.tsx
  - /Users/dweinbeck/Documents/todoist/src/components/tasks/sidebar.tsx
  - /Users/dweinbeck/Documents/todoist/src/components/tasks/task-card.tsx
  - /Users/dweinbeck/Documents/todoist/src/components/tasks/task-form.tsx
  - /Users/dweinbeck/Documents/todoist/src/components/tasks/quick-add-modal.tsx
  - /Users/dweinbeck/Documents/todoist/src/components/tasks/section-header.tsx
  - /Users/dweinbeck/Documents/todoist/src/components/tasks/add-section-button.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/[projectId]/project-view.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/tags/tag-list.tsx
  - /Users/dweinbeck/Documents/todoist/src/app/tasks/completed/completed-view.tsx
autonomous: true
must_haves:
  truths:
    - "All service functions accept userId as their first parameter"
    - "All server actions verify the Firebase ID token before proceeding and return error if unauthorized"
    - "All Server Component pages read userId from cookie and redirect if not authenticated"
    - "Workspace queries filter by userId -- creating workspace as User A returns nothing when queried as User B"
    - "Task queries (today, completed, search) include userId filter"
    - "Tag queries filter by userId -- each user has independent tag namespace"
    - "Project and Section mutations verify ownership through parent workspace chain"
    - "Client components pass ID token to server actions"
  artifacts:
    - path: "src/services/workspace.service.ts"
      provides: "userId-scoped workspace CRUD"
      exports: ["getWorkspaces", "getWorkspace", "createWorkspace", "updateWorkspace", "deleteWorkspace"]
    - path: "src/services/task.service.ts"
      provides: "userId-scoped task CRUD and queries"
      exports: ["createTask", "updateTask", "deleteTask", "toggleTaskStatus", "getTasksForToday", "getCompletedTasks", "searchTasks"]
    - path: "src/services/tag.service.ts"
      provides: "userId-scoped tag CRUD"
      exports: ["getTags", "createTag", "updateTag", "deleteTag", "getTasksByTag"]
    - path: "src/services/project.service.ts"
      provides: "Ownership-verified project CRUD"
      exports: ["getAllProjects", "getProject", "createProject", "updateProject", "deleteProject"]
    - path: "src/services/section.service.ts"
      provides: "Ownership-verified section CRUD"
      exports: ["createSection", "updateSection", "deleteSection", "reorderSection"]
    - path: "src/actions/workspace.ts"
      provides: "Token-verified workspace actions"
    - path: "src/actions/task.ts"
      provides: "Token-verified task actions"
    - path: "src/actions/tag.ts"
      provides: "Token-verified tag actions"
    - path: "src/app/tasks/layout.tsx"
      provides: "Cookie-authenticated layout passing userId to service calls"
      contains: "getUserIdFromCookie"
  key_links:
    - from: "src/actions/workspace.ts"
      to: "src/lib/auth.ts"
      via: "verifyUser(idToken) call"
      pattern: "verifyUser"
    - from: "src/actions/task.ts"
      to: "src/lib/auth.ts"
      via: "verifyUser(idToken) call"
      pattern: "verifyUser"
    - from: "src/app/tasks/layout.tsx"
      to: "src/lib/auth.ts"
      via: "getUserIdFromCookie() call"
      pattern: "getUserIdFromCookie"
    - from: "src/services/workspace.service.ts"
      to: "prisma.workspace"
      via: "where: { userId } in all queries"
      pattern: "where.*userId"
    - from: "src/services/task.service.ts"
      to: "prisma.task"
      via: "where: { userId } in all queries"
      pattern: "where.*userId"
    - from: "src/services/project.service.ts"
      to: "prisma.project"
      via: "workspace: { userId } join for ownership"
      pattern: "workspace.*userId"
    - from: "src/components/tasks/sidebar.tsx"
      to: "src/context/AuthContext.tsx"
      via: "useAuth() to get token for action calls"
      pattern: "useAuth|getIdToken"
---

<objective>
Add userId enforcement to every service function, server action, Server Component page, and client component in the todoist app. This is the comprehensive query audit that ensures complete data isolation between users.

Purpose: This is where AUTH-02, AUTH-03, and AUTH-04 are satisfied. Without this, userId columns exist but are not enforced, meaning all data is still globally visible.
Output: Every data path in the application is userId-scoped. No query can return or modify another user's data.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-multi-user-auth/33-RESEARCH.md
@.planning/phases/33-multi-user-auth/33-01-SUMMARY.md
@.planning/phases/33-multi-user-auth/33-02-SUMMARY.md

IMPORTANT: This plan operates in the **todoist** repo at `/Users/dweinbeck/Documents/todoist`.
All file paths below are relative to that repo. Run all commands from that directory.
Do NOT modify files in the personal-brand repo.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add userId to all service functions</name>
  <files>
    /Users/dweinbeck/Documents/todoist/src/services/workspace.service.ts
    /Users/dweinbeck/Documents/todoist/src/services/project.service.ts
    /Users/dweinbeck/Documents/todoist/src/services/section.service.ts
    /Users/dweinbeck/Documents/todoist/src/services/task.service.ts
    /Users/dweinbeck/Documents/todoist/src/services/tag.service.ts
  </files>
  <action>
    Work in `/Users/dweinbeck/Documents/todoist`. Verify with `pwd` before making changes.

    **workspace.service.ts -- Direct userId filtering (5 functions):**

    Every function gets `userId: string` as its FIRST parameter.

    - `getWorkspaces(userId)`: Add `where: { userId }` to `findMany`
    - `getWorkspace(userId, id)`: Change `where: { id }` to `where: { id, userId }`
    - `createWorkspace(userId, input)`: Add `userId` to `data: { userId, name: input.name }`
    - `updateWorkspace(userId, input)`: Change `where: { id: input.id }` to `where: { id: input.id, userId }`
    - `deleteWorkspace(userId, id)`: Change `where: { id }` to `where: { id, userId }`

    **project.service.ts -- Ownership through workspace chain (5 functions):**

    Every function gets `userId: string` as its FIRST parameter.

    - `getAllProjects(userId)`: Add `where: { workspace: { userId } }` to `findMany`. Keep the existing `select` and `orderBy`.
    - `getProject(userId, id)`: Add ownership verification. After `findUnique({ where: { id } })`, include `workspace: { select: { userId: true } }` in the include. Check `if (!project || project.workspace.userId !== userId) return null`. Remove workspace from the returned object before returning (or adjust the include to not expose it to callers -- simplest: add `workspace: { select: { userId: true } }` to the existing include, then verify ownership). IMPORTANT: The current `getProject` returns a complex nested structure with sections and tasks. Add the workspace include alongside existing includes:
      ```typescript
      include: {
        workspace: { select: { userId: true } },  // ADD THIS
        sections: { ... },  // KEEP EXISTING
        tasks: { ... },     // KEEP EXISTING
      }
      ```
      After the query, check `if (!project || project.workspace.userId !== userId) return null`.

    - `createProject(userId, input)`: Before creating, verify workspace ownership:
      ```typescript
      const workspace = await prisma.workspace.findUnique({
        where: { id: input.workspaceId, userId },
      });
      if (!workspace) throw new Error("Workspace not found");
      ```
      Then proceed with existing create.

    - `updateProject(userId, input)`: Before updating, verify ownership through workspace:
      ```typescript
      const existing = await prisma.project.findUnique({
        where: { id: input.id },
        include: { workspace: { select: { userId: true } } },
      });
      if (!existing || existing.workspace.userId !== userId) throw new Error("Not found");
      ```
      Then proceed with existing update.

    - `deleteProject(userId, id)`: Same ownership check pattern as updateProject, then delete.

    **section.service.ts -- Ownership through project->workspace chain (4 functions):**

    Every function gets `userId: string` as its FIRST parameter.

    Create a helper function at the top of the file:
    ```typescript
    async function verifyProjectOwnership(projectId: string, userId: string) {
      const project = await prisma.project.findUnique({
        where: { id: projectId },
        include: { workspace: { select: { userId: true } } },
      });
      if (!project || project.workspace.userId !== userId) {
        throw new Error("Not found");
      }
      return project;
    }
    ```

    For sections, we also need a helper to verify section ownership:
    ```typescript
    async function verifySectionOwnership(sectionId: string, userId: string) {
      const section = await prisma.section.findUnique({
        where: { id: sectionId },
        include: { project: { include: { workspace: { select: { userId: true } } } } },
      });
      if (!section || section.project.workspace.userId !== userId) {
        throw new Error("Not found");
      }
      return section;
    }
    ```

    - `createSection(userId, input)`: Call `verifyProjectOwnership(input.projectId, userId)` before proceeding. Keep existing order logic.
    - `updateSection(userId, input)`: Call `verifySectionOwnership(input.id, userId)` before proceeding.
    - `deleteSection(userId, id)`: Call `verifySectionOwnership(id, userId)` before proceeding.
    - `reorderSection(userId, input)`: Call `verifySectionOwnership(input.id, userId)` before proceeding.

    **task.service.ts -- Direct userId filtering (9 functions):**

    Every function gets `userId: string` as its FIRST parameter.

    - `createTask(userId, input)`: Add `userId` to the `data` object in `prisma.task.create`. Also, when checking parent task, add `userId` to the where: `prisma.task.findUnique({ where: { id: input.parentTaskId, userId } })`. When finding last task for ordering, add `userId` to the where clause.
    - `updateTask(userId, input)`: Add `userId` to the `where: { id, userId }` in the update call. Also add `userId` to `deleteMany` for TaskTag: `where: { taskId: id, task: { userId } }` -- actually simpler: just add `userId` to the main task update where clause. The TaskTag deleteMany can stay as `{ where: { taskId: id } }` since we already verified the task belongs to the user.
      CORRECTION: For safety, verify task ownership first with `prisma.task.findUnique({ where: { id, userId } })`. If not found, throw. Then proceed with existing update logic (TaskTag deleteMany by taskId is safe after ownership verified).
    - `deleteTask(userId, id)`: Change to `where: { id, userId }`
    - `toggleTaskStatus(userId, id)`: Change findUnique to `where: { id, userId }`. Keep existing status toggle logic.
    - `assignTaskToSection(userId, taskId, sectionId)`: Add `userId` to task update `where: { id: taskId, userId }`. If sectionId is provided, also verify section ownership.
    - `reorderTask(userId, input)`: Change to `where: { id: input.id, userId }`
    - `getTasksForToday(userId)`: Add `userId` to the where clause alongside existing deadlineAt and status filters.
    - `getCompletedTasks(userId, projectId?)`: Add `userId` to the where clause alongside existing status filter.
    - `searchTasks(userId, query)`: Add `userId` to the where clause. The `OR` for name/description search should be nested inside an `AND` with the userId filter:
      ```typescript
      where: {
        userId,
        parentTaskId: null,
        OR: [
          { name: { contains: query, mode: "insensitive" } },
          { description: { contains: query, mode: "insensitive" } },
        ],
      }
      ```

    **tag.service.ts -- Direct userId filtering (5 functions):**

    Every function gets `userId: string` as its FIRST parameter.

    - `getTags(userId)`: Add `where: { userId }` to `findMany`
    - `createTag(userId, input)`: Add `userId` to `data: { userId, name, color }`
    - `updateTag(userId, input)`: Change to `where: { id, userId }` (compound where with destructure)
    - `deleteTag(userId, id)`: Change to `where: { id, userId }`
    - `getTasksByTag(userId, tagId)`: Add `userId` to the task findMany where clause. Also verify tag ownership: check `where: { id: tagId, userId }` on the tag first, throw if not found. Then query tasks with `where: { userId, parentTaskId: null, tags: { some: { tagId } } }`.
  </action>
  <verify>
    Run `cd /Users/dweinbeck/Documents/todoist && npx tsc --noEmit 2>&1 | head -50`. TypeScript will show errors for every call site that hasn't been updated yet (actions and pages). This is EXPECTED -- it confirms the service signatures changed. Count the errors to verify all 28 service functions were updated. After Task 2, these errors will be resolved.
  </verify>
  <done>
    All 28 service functions across 5 files accept userId as first parameter. Every Prisma query includes userId filtering. Project and Section verify ownership through parent chain. No query can return or modify data without the correct userId.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update all actions, pages, and client components for auth</name>
  <files>
    /Users/dweinbeck/Documents/todoist/src/actions/workspace.ts
    /Users/dweinbeck/Documents/todoist/src/actions/project.ts
    /Users/dweinbeck/Documents/todoist/src/actions/section.ts
    /Users/dweinbeck/Documents/todoist/src/actions/task.ts
    /Users/dweinbeck/Documents/todoist/src/actions/tag.ts
    /Users/dweinbeck/Documents/todoist/src/app/tasks/layout.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/page.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/[projectId]/page.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/today/page.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/completed/page.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/search/page.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/tags/page.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/tags/[tagId]/page.tsx
    /Users/dweinbeck/Documents/todoist/src/components/tasks/sidebar.tsx
    /Users/dweinbeck/Documents/todoist/src/components/tasks/task-card.tsx
    /Users/dweinbeck/Documents/todoist/src/components/tasks/task-form.tsx
    /Users/dweinbeck/Documents/todoist/src/components/tasks/quick-add-modal.tsx
    /Users/dweinbeck/Documents/todoist/src/components/tasks/section-header.tsx
    /Users/dweinbeck/Documents/todoist/src/components/tasks/add-section-button.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/[projectId]/project-view.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/tags/tag-list.tsx
    /Users/dweinbeck/Documents/todoist/src/app/tasks/completed/completed-view.tsx
  </files>
  <action>
    Work in `/Users/dweinbeck/Documents/todoist`. Verify with `pwd` before making changes.

    **PART A -- Server Actions (5 files):**

    Every server action now takes `idToken: string` as its FIRST parameter. Import `verifyUser` from `@/lib/auth`. Verify token at the start, return `{ error: "Unauthorized" }` if null.

    **workspace.ts:**
    - `createWorkspaceAction(idToken: string, formData: FormData)`: Verify token, get userId, pass to `createWorkspaceSvc(userId, parsed.data)` (note: service now takes userId as first arg, so it's `createWorkspaceSvc(userId, parsed.data)`)
    - `updateWorkspaceAction(idToken: string, formData: FormData)`: Verify token, pass userId to `updateWorkspaceSvc(userId, parsed.data)`
    - `deleteWorkspaceAction(idToken: string, id: string)`: Verify token, pass userId to `deleteWorkspaceSvc(userId, id)`

    **project.ts:**
    - `createProjectAction(idToken: string, formData: FormData)`: Verify token, pass userId to `createProjectSvc(userId, parsed.data)`
    - `updateProjectAction(idToken: string, formData: FormData)`: Verify token, pass userId
    - `deleteProjectAction(idToken: string, id: string)`: Verify token, pass userId

    **section.ts:**
    - `createSectionAction(idToken: string, formData: FormData)`: Verify, pass userId
    - `updateSectionAction(idToken: string, formData: FormData)`: Verify, pass userId
    - `deleteSectionAction(idToken: string, id: string)`: Verify, pass userId

    **task.ts:**
    - `createTaskAction(idToken: string, data: {...})`: Verify token, pass userId to `createTaskSvc(userId, parsed.data)`
    - `updateTaskAction(idToken: string, data: {...})`: Verify, pass userId
    - `deleteTaskAction(idToken: string, id: string)`: Verify, pass userId
    - `toggleTaskAction(idToken: string, id: string)`: Verify, pass userId
    - `assignTaskToSectionAction(idToken: string, taskId: string, sectionId: string | null)`: Verify, pass userId

    **tag.ts:**
    - `createTagAction(idToken: string, data: {...})`: Verify, pass userId
    - `updateTagAction(idToken: string, data: {...})`: Verify, pass userId
    - `deleteTagAction(idToken: string, id: string)`: Verify, pass userId

    Pattern for each action:
    ```typescript
    export async function createWorkspaceAction(idToken: string, formData: FormData) {
      const userId = await verifyUser(idToken);
      if (!userId) return { error: "Unauthorized" };
      // ... existing validation logic ...
      await createWorkspaceSvc(userId, parsed.data);
      // ... existing revalidation ...
    }
    ```

    **PART B -- Server Component Pages (8 pages):**

    Every page imports `getUserIdFromCookie` from `@/lib/auth` and `redirect` from `next/navigation`. At the top of the component, read userId and redirect if not authenticated.

    Wrap each page's tasks layout with AuthGuard. Two approaches -- we use BOTH:
    1. Server Components: `getUserIdFromCookie()` for data fetching
    2. Client-side: AuthGuard in the tasks layout for sign-in UI

    **tasks/layout.tsx:**
    - Import `getUserIdFromCookie` from `@/lib/auth`, `redirect` from `next/navigation`, `AuthGuard` from `@/components/auth/AuthGuard`
    - At the top: `const userId = await getUserIdFromCookie(); if (!userId) redirect("/");`
    - Pass `userId` to service calls: `getWorkspaces(userId)`, `getTags(userId)`
    - Wrap the return JSX: the outer div and sidebar stay as Server Component content, but wrap `{children}` area with nothing extra (AuthGuard is in root layout or handled by redirect)
    - Actually, since Server Components can't render client-component guards around server data fetching, the `redirect("/")` is the server-side protection. The client-side AuthGuard in the root redirect handles showing the sign-in UI.

    Wait -- better approach: The root `page.tsx` currently redirects to `/tasks`. Instead:
    - Update `src/app/page.tsx` to be a client component that renders AuthGuard wrapping a redirect trigger. OR simpler: keep the server redirect, and add the AuthGuard around the tasks layout content.

    REVISED APPROACH for cleaner UX:
    - `src/app/page.tsx`: Keep as server component with `redirect("/tasks")` (unchanged)
    - `src/app/tasks/layout.tsx`: Read cookie, if no userId, render a client-side AuthGuard wrapper instead of the normal layout:
      ```typescript
      export default async function TasksLayout({ children }) {
        const userId = await getUserIdFromCookie();

        if (!userId) {
          return <AuthGuard>{null}</AuthGuard>;
        }

        const [workspaces, tags] = await Promise.all([
          getWorkspaces(userId),
          getTags(userId),
        ]);
        // ... rest unchanged
      }
      ```
      This way, unauthenticated users see the sign-in UI. Authenticated users see the sidebar + content. Import AuthGuard at the top.

    **tasks/page.tsx:**
    - Add cookie read: `const userId = await getUserIdFromCookie(); if (!userId) redirect("/");`
    - Pass userId: `getWorkspaces(userId)`

    **tasks/[projectId]/page.tsx:**
    - Add cookie read + redirect
    - Pass userId: `getProject(userId, projectId)`, `getTags(userId)`

    **tasks/today/page.tsx:**
    - Add cookie read + redirect
    - Pass userId: `getTasksForToday(userId)`, `getTags(userId)`

    **tasks/completed/page.tsx:**
    - Add cookie read + redirect
    - Pass userId: `getCompletedTasks(userId, projectId)`, `getAllProjects(userId)`

    **tasks/search/page.tsx:**
    - Add cookie read + redirect
    - Pass userId: `searchTasks(userId, query)` (only when query is non-empty), `getTags(userId)`

    **tasks/tags/page.tsx:**
    - Add cookie read + redirect
    - Pass userId: `getTags(userId)`

    **tasks/tags/[tagId]/page.tsx:**
    - Add cookie read + redirect
    - Pass userId: `getTasksByTag(userId, tagId)`, `getTags(userId)`

    **PART C -- Client Components (8 components):**

    Every client component that calls a server action must:
    1. Import `useAuth` from `@/context/AuthContext`
    2. Call `useAuth()` to get `{ user }`
    3. Before calling any action, get the token: `const token = await user!.getIdToken()`
    4. Pass token as first argument to the action

    **sidebar.tsx** (calls createWorkspaceAction, deleteWorkspaceAction, createProjectAction, deleteProjectAction):
    - Import `useAuth` from `@/context/AuthContext`
    - In component: `const { user } = useAuth()`
    - In `handleAddWorkspace`: `const token = await user!.getIdToken(); await createWorkspaceAction(token, formData);`
    - In `handleAddProject`: `const token = await user!.getIdToken(); await createProjectAction(token, formData);`
    - In `handleDelete`: get token, pass to `deleteWorkspaceAction(token, ...)` or `deleteProjectAction(token, ...)`

    **task-card.tsx** (calls deleteTaskAction, toggleTaskAction):
    - Import `useAuth`, get user
    - Before each action call: get token, pass as first arg

    **task-form.tsx** (calls createTaskAction, updateTaskAction):
    - Import `useAuth`, get user
    - Before each action call: get token, pass as first arg

    **quick-add-modal.tsx** (calls createTaskAction):
    - Import `useAuth`, get user
    - Before action call: get token, pass as first arg

    **section-header.tsx** (calls deleteSectionAction, updateSectionAction):
    - Import `useAuth`, get user
    - Before each action call: get token, pass as first arg

    **add-section-button.tsx** (calls createSectionAction):
    - Import `useAuth`, get user
    - Before action call: get token, pass as first arg

    **project-view.tsx** (calls updateProjectAction):
    - Import `useAuth`, get user
    - Before action call: get token, pass as first arg

    **tag-list.tsx** (calls createTagAction, deleteTagAction):
    - Import `useAuth`, get user
    - Before each action call: get token, pass as first arg

    **completed-view.tsx**: This is a client component but does NOT call any actions directly (it just renders UI with filter). No changes needed unless it calls actions -- verify by reading the file.
  </action>
  <verify>
    Run `cd /Users/dweinbeck/Documents/todoist && npm run lint && npm run build`. Both must pass with zero errors. Then verify auth enforcement by grepping:
    - `grep -r "verifyUser" src/actions/` should show verifyUser in every action file
    - `grep -r "getUserIdFromCookie" src/app/tasks/` should show cookie read in layout and/or pages
    - `grep -r "useAuth" src/components/tasks/` should show useAuth in every client component that calls actions
    - `grep -r "getIdToken" src/components/` should show token retrieval in client components
  </verify>
  <done>
    Every data path is userId-scoped:
    - 28 service functions accept userId as first parameter with Prisma queries filtered
    - 15 server actions verify Firebase ID token before proceeding
    - 8 Server Component pages read userId from cookie and redirect if unauthenticated
    - 8 client components pass ID token to action calls
    - Build and lint pass cleanly
    - No Prisma query can return or modify another user's data
  </done>
</task>

</tasks>

<verification>
1. `cd /Users/dweinbeck/Documents/todoist && npm run build` passes
2. `cd /Users/dweinbeck/Documents/todoist && npm run lint` passes
3. `cd /Users/dweinbeck/Documents/todoist && npm test` passes (existing tests still work)
4. Every service function signature starts with `userId: string` -- verify with `grep -n "export async function" src/services/*.ts`
5. Every action file imports and calls `verifyUser` -- verify with `grep -l "verifyUser" src/actions/*.ts` (should return all 5 files)
6. Every Server Component page reads cookie -- verify with `grep -rl "getUserIdFromCookie" src/app/tasks/`
7. Every client component calling actions uses `getIdToken` -- verify with `grep -rl "getIdToken" src/components/tasks/ src/app/tasks/`
8. No Prisma query in services lacks `userId` -- verify with `grep -n "prisma\." src/services/*.ts` and confirm each has userId context
</verification>

<success_criteria>
- AUTH-02 satisfied: Users see only their own data (every query filters by userId)
- AUTH-03 satisfied: All Prisma queries include userId filter
- AUTH-04 satisfied: Server derives userId from verified Firebase token via verifyUser() -- never from client input
- All server actions return { error: "Unauthorized" } when token verification fails
- All Server Component pages redirect when cookie-based auth fails
- All client components pass fresh ID token to action calls
- Build, lint, and tests pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/33-multi-user-auth/33-03-SUMMARY.md`
</output>
