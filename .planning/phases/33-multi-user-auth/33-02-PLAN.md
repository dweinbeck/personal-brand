---
phase: 33-multi-user-auth
plan: 02
type: execute
wave: 2
depends_on: ["33-01"]
files_modified:
  - /Users/dweinbeck/Documents/todoist/prisma/schema.prisma
  - /Users/dweinbeck/Documents/todoist/scripts/backfill-userid.ts
  - /Users/dweinbeck/Documents/todoist/src/generated/prisma
autonomous: false
must_haves:
  truths:
    - "Workspace model has a required userId column with an index"
    - "Task model has a required userId column with indexes on [userId, status] and [userId, deadlineAt]"
    - "Tag model has a required userId column with @@unique([userId, name]) replacing the old @unique on name"
    - "All existing data is backfilled with the developer's Firebase UID"
    - "Prisma client is regenerated with the new schema"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Updated schema with userId on Workspace, Task, Tag"
      contains: "userId"
    - path: "scripts/backfill-userid.ts"
      provides: "One-time backfill script for existing data"
      min_lines: 20
    - path: "src/generated/prisma"
      provides: "Regenerated Prisma client with userId fields"
  key_links:
    - from: "prisma/schema.prisma"
      to: "src/generated/prisma"
      via: "prisma generate"
      pattern: "userId.*String"
    - from: "scripts/backfill-userid.ts"
      to: "prisma/schema.prisma"
      via: "uses PrismaClient to update rows"
      pattern: "prisma\\.(workspace|task|tag)\\.updateMany"
---

<objective>
Add userId columns to Workspace, Task, and Tag models using the expand-and-contract migration pattern: add as nullable, backfill existing data, then make required. Update Tag uniqueness from global to per-user.

Purpose: Without userId columns, the query audit in Plan 03 cannot scope data by user. This is the data layer prerequisite.
Output: Schema with required userId on 3 models, all existing data backfilled, Prisma client regenerated.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-multi-user-auth/33-RESEARCH.md
@.planning/phases/33-multi-user-auth/33-01-SUMMARY.md

IMPORTANT: This plan operates in the **todoist** repo at `/Users/dweinbeck/Documents/todoist`.
All file paths below are relative to that repo. Run all commands from that directory.
Do NOT modify files in the personal-brand repo.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand schema (nullable userId) and create backfill script</name>
  <files>
    /Users/dweinbeck/Documents/todoist/prisma/schema.prisma
    /Users/dweinbeck/Documents/todoist/scripts/backfill-userid.ts
  </files>
  <action>
    Work in `/Users/dweinbeck/Documents/todoist`. Verify with `pwd` before making changes.

    **Step 1 -- Expand schema (add nullable userId columns):**

    Update `prisma/schema.prisma`:

    a) Workspace model -- add `userId String?` field and `@@index([userId])`:
    ```prisma
    model Workspace {
      id        String    @id @default(cuid())
      userId    String?
      name      String
      projects  Project[]
      createdAt DateTime  @default(now())
      updatedAt DateTime  @updatedAt

      @@index([userId])
    }
    ```

    b) Task model -- add `userId String?` field and two indexes:
    ```prisma
    model Task {
      id           String    @id @default(cuid())
      userId       String?
      projectId    String
      // ... all other existing fields unchanged ...

      @@index([userId, status])
      @@index([userId, deadlineAt])
    }
    ```

    c) Tag model -- add `userId String?` field, REMOVE the `@unique` from `name`, add `@@index([userId])`:
    ```prisma
    model Tag {
      id    String    @id @default(cuid())
      userId String?
      name  String
      color String?
      tasks TaskTag[]

      @@index([userId])
    }
    ```
    NOTE: Do NOT add `@@unique([userId, name])` yet -- cannot add unique constraint on nullable column with existing data. That comes in the contract step after backfill.

    d) Push the schema change:
    ```bash
    cd /Users/dweinbeck/Documents/todoist && npx prisma db push --accept-data-loss
    ```
    The `--accept-data-loss` flag is needed because removing `@unique` from Tag.name is a destructive change (drops the unique index). This is intentional.

    e) Regenerate the Prisma client:
    ```bash
    cd /Users/dweinbeck/Documents/todoist && npx prisma generate
    ```

    **Step 2 -- Create backfill script:**

    Create `scripts/backfill-userid.ts`:
    ```typescript
    import "dotenv/config";
    import { PrismaClient } from "../src/generated/prisma/client";

    const DEFAULT_USER_ID = process.env.BACKFILL_USER_ID;

    if (!DEFAULT_USER_ID) {
      console.error("Set BACKFILL_USER_ID environment variable to the Firebase UID to assign existing data to.");
      process.exit(1);
    }

    const prisma = new PrismaClient();

    async function main() {
      console.log(`Backfilling userId=${DEFAULT_USER_ID} on all existing data...`);

      const workspaceResult = await prisma.workspace.updateMany({
        where: { userId: null },
        data: { userId: DEFAULT_USER_ID },
      });
      console.log(`  Workspaces updated: ${workspaceResult.count}`);

      const taskResult = await prisma.task.updateMany({
        where: { userId: null },
        data: { userId: DEFAULT_USER_ID },
      });
      console.log(`  Tasks updated: ${taskResult.count}`);

      const tagResult = await prisma.tag.updateMany({
        where: { userId: null },
        data: { userId: DEFAULT_USER_ID },
      });
      console.log(`  Tags updated: ${tagResult.count}`);

      console.log("Backfill complete.");
    }

    main()
      .catch((e) => {
        console.error("Backfill failed:", e);
        process.exit(1);
      })
      .finally(() => prisma.$disconnect());
    ```
  </action>
  <verify>
    Run `cd /Users/dweinbeck/Documents/todoist && npx prisma db push --dry-run 2>&1 | head -20` to verify schema is valid. Verify `scripts/backfill-userid.ts` exists and has the correct structure.
  </verify>
  <done>
    Schema has nullable userId on Workspace, Task, Tag. Tag.name no longer has @unique. Backfill script exists and reads BACKFILL_USER_ID from environment. Prisma client regenerated with new fields.
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Run backfill and contract schema</name>
  <what-built>The schema has nullable userId columns on Workspace, Task, and Tag. A backfill script is ready to assign all existing data to your Firebase UID.</what-built>
  <action>
    The user needs to provide their Firebase UID so the backfill can run. After backfill, the schema is contracted to make userId required.

    **Step 1 -- User provides Firebase UID:**

    The user must set the `BACKFILL_USER_ID` environment variable to their Firebase UID.

    To find your Firebase UID:
    - Go to Firebase Console -> Authentication -> Users
    - Find your Google account and copy the "User UID" column value

    **Step 2 -- Run backfill:**
    ```bash
    cd /Users/dweinbeck/Documents/todoist
    BACKFILL_USER_ID=<your-firebase-uid> npx tsx scripts/backfill-userid.ts
    ```

    **Step 3 -- Contract schema (make userId required):**

    After backfill succeeds, update `prisma/schema.prisma`:

    a) Change `userId String?` to `userId String` on Workspace, Task, and Tag models

    b) Add `@@unique([userId, name])` to the Tag model (now safe because all rows have userId):
    ```prisma
    model Tag {
      id     String    @id @default(cuid())
      userId String
      name   String
      color  String?
      tasks  TaskTag[]

      @@unique([userId, name])
      @@index([userId])
    }
    ```

    c) Push the contracted schema:
    ```bash
    cd /Users/dweinbeck/Documents/todoist && npx prisma db push
    ```

    d) Regenerate Prisma client:
    ```bash
    cd /Users/dweinbeck/Documents/todoist && npx prisma generate
    ```
  </action>
  <how-to-verify>
    1. Run `cd /Users/dweinbeck/Documents/todoist && npx prisma studio` and verify Workspace, Task, and Tag tables all have a non-null userId value on every row
    2. Run `cd /Users/dweinbeck/Documents/todoist && npm run build` to verify the build passes with the new schema
  </how-to-verify>
  <resume-signal>Type "backfill complete" after running the backfill and contracting the schema, or provide your Firebase UID for Claude to run the backfill</resume-signal>
</task>

</tasks>

<verification>
1. `prisma/schema.prisma` has `userId String` (required, not optional) on Workspace, Task, and Tag
2. Tag model has `@@unique([userId, name])` instead of `@unique` on `name`
3. Workspace has `@@index([userId])`
4. Task has `@@index([userId, status])` and `@@index([userId, deadlineAt])`
5. `cd /Users/dweinbeck/Documents/todoist && npm run build` passes
6. All existing database rows have a non-null userId
</verification>

<success_criteria>
- userId is a required String column on Workspace, Task, and Tag models
- Tag uniqueness is per-user (@@unique([userId, name]))
- All existing data is backfilled with the developer's Firebase UID
- Prisma client is regenerated and build passes
- Backfill script exists at scripts/backfill-userid.ts for reference
</success_criteria>

<output>
After completion, create `.planning/phases/33-multi-user-auth/33-02-SUMMARY.md`
</output>
