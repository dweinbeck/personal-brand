---
phase: 30-assets-page-user-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/brand-scraper/history.ts
  - src/lib/brand-scraper/types.ts
  - src/app/api/tools/brand-scraper/scrape/route.ts
  - src/app/api/tools/brand-scraper/jobs/[id]/route.ts
  - src/app/api/tools/brand-scraper/history/route.ts
autonomous: true

must_haves:
  truths:
    - "Scrape submissions persist a history record in Firestore with jobId, siteUrl, createdAt, and status"
    - "History records are updated to terminal status when job polling detects succeeded/partial/failed"
    - "Authenticated GET request to /api/tools/brand-scraper/history returns the user's scrape history sorted newest first"
    - "History entries are scoped to the authenticated user (no cross-user leakage)"
  artifacts:
    - path: "src/lib/brand-scraper/history.ts"
      provides: "Firestore helpers for scrape_history collection (add, update status, get user history)"
      exports: ["addHistoryEntry", "updateHistoryStatus", "getUserHistory"]
    - path: "src/lib/brand-scraper/types.ts"
      provides: "ScrapeHistoryEntry client-side type for API responses"
      contains: "ScrapeHistoryEntry"
    - path: "src/app/api/tools/brand-scraper/history/route.ts"
      provides: "GET handler returning authenticated user's history"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/tools/brand-scraper/scrape/route.ts"
      to: "src/lib/brand-scraper/history.ts"
      via: "addHistoryEntry call after job submission succeeds"
      pattern: "addHistoryEntry"
    - from: "src/app/api/tools/brand-scraper/jobs/[id]/route.ts"
      to: "src/lib/brand-scraper/history.ts"
      via: "updateHistoryStatus call on terminal job status"
      pattern: "updateHistoryStatus"
    - from: "src/app/api/tools/brand-scraper/history/route.ts"
      to: "src/lib/brand-scraper/history.ts"
      via: "getUserHistory call with auth.uid"
      pattern: "getUserHistory"
---

<objective>
Build the Firestore-backed scrape history backend: collection helpers, history writes on scrape submission and terminal job poll, and an authenticated history API route.

Purpose: Provides the data layer for HIST-01 (persistence), HIST-02 (authenticated fetch), and the terminal status updates. This is the foundation that the history UI (Plan 03) will consume.
Output: Three new files (history.ts helpers, history API route, updated types.ts) and two modified route files with history writes.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-assets-page-user-history/30-RESEARCH.md

# Reference files for patterns
@src/lib/billing/firestore.ts (Firestore collection helper pattern: requireDb, collection helpers)
@src/lib/firebase.ts (db export)
@src/app/api/tools/brand-scraper/scrape/route.ts (scrape submission flow -- modify to add history write)
@src/app/api/tools/brand-scraper/jobs/[id]/route.ts (job status flow -- modify to add history status update)
@src/lib/auth/user.ts (verifyUser, unauthorizedResponse -- for history API route auth)
@src/lib/brand-scraper/types.ts (add ScrapeHistoryEntry type here)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Firestore history helpers and ScrapeHistoryEntry type</name>
  <files>
    src/lib/brand-scraper/history.ts
    src/lib/brand-scraper/types.ts
  </files>
  <action>
Create `src/lib/brand-scraper/history.ts` following the pattern from `src/lib/billing/firestore.ts`:

1. Import `FieldValue` from `firebase-admin/firestore` and `db` from `@/lib/firebase`.
2. Create `requireDb()` helper (same pattern as billing).
3. Create `historyCol()` returning `requireDb().collection("scrape_history")`.
4. Export `addHistoryEntry({ uid, jobId, siteUrl })`:
   - Document ID: `${uid}_${jobId}` (compound key for idempotency).
   - Fields: `uid`, `jobId`, `siteUrl`, `status: "queued"`, `createdAt: FieldValue.serverTimestamp()`, `updatedAt: FieldValue.serverTimestamp()`.
   - Uses `.set()` (idempotent -- safe for retries).
5. Export `updateHistoryStatus({ uid, jobId, status })`:
   - Document ID: `${uid}_${jobId}`.
   - Get doc first; if it doesn't exist, return silently (no error).
   - Update `status` and `updatedAt: FieldValue.serverTimestamp()`.
6. Export `getUserHistory(uid, limit = 20)`:
   - Query: `.where("uid", "==", uid).orderBy("createdAt", "desc").limit(limit)`.
   - Returns array of `{ id, uid, jobId, siteUrl, status, createdAt, updatedAt }`.
   - Convert Firestore Timestamps to ISO strings for serialization.

Add to `src/lib/brand-scraper/types.ts` at the bottom:

```typescript
/**
 * Client-side type for scrape history API responses.
 * Firestore Timestamps are serialized to ISO strings by the API route.
 */
export type ScrapeHistoryEntry = {
  id: string;
  jobId: string;
  siteUrl: string;
  status: string;
  createdAt: string;
  updatedAt: string;
};
```

Do NOT add `uid` to the client-side type -- it's server-internal.
  </action>
  <verify>
Run `npm run build` to confirm no TypeScript errors in the new files. Check that the types.ts file exports `ScrapeHistoryEntry` and history.ts exports all three functions.
  </verify>
  <done>
`history.ts` exports `addHistoryEntry`, `updateHistoryStatus`, `getUserHistory`. `types.ts` exports `ScrapeHistoryEntry`. Both compile without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire history writes into scrape and job status routes, create history API route</name>
  <files>
    src/app/api/tools/brand-scraper/scrape/route.ts
    src/app/api/tools/brand-scraper/jobs/[id]/route.ts
    src/app/api/tools/brand-scraper/history/route.ts
  </files>
  <action>
**Modify `scrape/route.ts`:**
1. Import `addHistoryEntry` from `@/lib/brand-scraper/history`.
2. After the `submitScrapeJob` call succeeds and `markUsageSucceeded` is called, add a fire-and-forget history write:
   ```typescript
   addHistoryEntry({
     uid: auth.uid,
     jobId: job.job_id,
     siteUrl: parsed.data.url,
   }).catch((err) => console.error("Failed to write scrape history:", err));
   ```
   This goes BEFORE the `return Response.json(...)` line, after the `markUsageSucceeded` call.
3. Do NOT await this -- it must be non-blocking (fire-and-forget with error logging).

**Modify `jobs/[id]/route.ts`:**
1. Import `updateHistoryStatus` from `@/lib/brand-scraper/history`.
2. After the existing terminal status handling (auto-refund for "failed", mark succeeded for "succeeded"/"partial"), add:
   ```typescript
   if (job.status === "succeeded" || job.status === "partial" || job.status === "failed") {
     updateHistoryStatus({
       uid: auth.uid,
       jobId: id,
       status: job.status,
     }).catch((err) => console.error("History status update failed:", err));
   }
   ```
   Place this AFTER the existing billing status updates, BEFORE the `return Response.json(...)` line.
3. Fire-and-forget -- do NOT await.

**Create `history/route.ts`:**
1. Import `verifyUser`, `unauthorizedResponse` from `@/lib/auth/user`.
2. Import `getUserHistory` from `@/lib/brand-scraper/history`.
3. Export `GET` handler:
   - Verify user auth. Return `unauthorizedResponse` if not authorized.
   - Call `await getUserHistory(auth.uid)`.
   - Return `Response.json({ entries: history })`.
4. No POST/PUT/DELETE -- read-only endpoint.
  </action>
  <verify>
Run `npm run build` to confirm no TypeScript errors. Run `npm run lint` to confirm no lint issues. Verify the history route file exists at the correct path.
  </verify>
  <done>
Scrape route writes history on successful job submission. Job status route updates history status on terminal states. GET /api/tools/brand-scraper/history returns authenticated user's history. All changes are fire-and-forget (non-blocking). Build and lint pass.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with no TypeScript errors
2. `npm run lint` passes with no lint issues
3. `npm test` passes (existing tests still work)
4. `src/lib/brand-scraper/history.ts` exports addHistoryEntry, updateHistoryStatus, getUserHistory
5. `src/lib/brand-scraper/types.ts` exports ScrapeHistoryEntry
6. `src/app/api/tools/brand-scraper/history/route.ts` exports GET
7. scrape/route.ts contains `addHistoryEntry` call
8. jobs/[id]/route.ts contains `updateHistoryStatus` call
</verification>

<success_criteria>
- History Firestore helpers compile and follow the established billing/firestore.ts pattern
- Scrape submission route writes history entry (fire-and-forget)
- Job status route updates history status on terminal states (fire-and-forget)
- History API route authenticates via verifyUser and returns user-scoped entries sorted by createdAt desc
- All quality gates pass (build, lint, test)
</success_criteria>

<output>
After completion, create `.planning/phases/30-assets-page-user-history/30-01-SUMMARY.md`
</output>
