---
phase: 21-brand-scraper-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/brand-scraper/types.ts
  - src/lib/brand-scraper/hooks.ts
  - src/components/admin/brand-scraper/BrandConfidenceBadge.tsx
  - src/components/admin/brand-scraper/UrlSubmitForm.tsx
  - src/components/admin/brand-scraper/JobStatusIndicator.tsx
  - package.json
autonomous: true

must_haves:
  truths:
    - "Job status updates automatically without manual page refresh"
    - "Form submission displays a job ID immediately after submitting a URL"
    - "Confidence badges appear on data items showing high/medium/low tiers as colored percentages"
    - "Polling stops automatically when a job reaches a terminal state (succeeded, partial, or failed)"
    - "Status indicator visually distinguishes between active (queued/processing) and terminal states"
    - "Unauthenticated users cannot submit scrape requests"
  artifacts:
    - path: "src/lib/brand-scraper/types.ts"
      provides: "Extended BrandTaxonomy Zod schema and type export"
      contains: "brandTaxonomySchema"
    - path: "src/lib/brand-scraper/hooks.ts"
      provides: "useJobStatus custom SWR hook with dynamic polling"
      exports: ["useJobStatus"]
    - path: "src/components/admin/brand-scraper/BrandConfidenceBadge.tsx"
      provides: "Numeric confidence to categorical badge component"
      exports: ["BrandConfidenceBadge"]
    - path: "src/components/admin/brand-scraper/UrlSubmitForm.tsx"
      provides: "URL input form with authenticated submission"
      exports: ["UrlSubmitForm"]
    - path: "src/components/admin/brand-scraper/JobStatusIndicator.tsx"
      provides: "Job status display with polling progress"
      exports: ["JobStatusIndicator"]
  key_links:
    - from: "src/lib/brand-scraper/hooks.ts"
      to: "/api/admin/brand-scraper/jobs/[id]"
      via: "SWR fetch with Bearer token"
      pattern: "api/admin/brand-scraper/jobs"
    - from: "src/components/admin/brand-scraper/UrlSubmitForm.tsx"
      to: "/api/admin/brand-scraper/scrape"
      via: "fetch POST with Bearer token"
      pattern: "api/admin/brand-scraper/scrape"
    - from: "src/lib/brand-scraper/hooks.ts"
      to: "src/lib/brand-scraper/types.ts"
      via: "import JobStatus type"
      pattern: "import.*JobStatus"
---

<objective>
Install SWR, extend brand scraper types with BrandTaxonomy schema, create the useJobStatus polling hook, and build the form/status UI components.

Purpose: This is the foundation for the brand scraper UI -- the polling mechanism, form submission, status display, and confidence badge. Plan 02 builds the gallery and orchestrator on top of these.

Output: SWR installed, BrandTaxonomy schema in types.ts, useJobStatus hook, UrlSubmitForm, JobStatusIndicator, and BrandConfidenceBadge components.

**PREREQUISITE: Phase 20 (Brand Scraper API Proxy) MUST be complete before this plan executes.** This plan extends `src/lib/brand-scraper/types.ts` created by Phase 20 and submits forms to API routes created by Phase 20. If those files do not exist, this plan will fail. The executor should verify Phase 20 artifacts exist before starting.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-brand-scraper-ui/21-RESEARCH.md

# Phase 20 artifacts (MUST exist before this plan runs -- created by Phase 20)
@src/lib/brand-scraper/types.ts
@src/lib/brand-scraper/client.ts

# Existing patterns to reuse
@src/components/assistant/ConfidenceBadge.tsx
@src/components/admin/TutorialEditor.tsx
@src/components/ui/Card.tsx
@src/components/ui/Button.tsx
@src/context/AuthContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 0: Verify Phase 20 prerequisites</name>
  <files>src/lib/brand-scraper/types.ts, src/lib/brand-scraper/client.ts</files>
  <action>
Before any implementation, verify that Phase 20 artifacts exist:

1. Check that `src/lib/brand-scraper/types.ts` exists and exports `scrapeRequestSchema`, `scrapeJobSubmissionSchema`, and `jobStatusSchema`.
2. Check that `src/lib/brand-scraper/client.ts` exists.
3. Check that `src/app/api/admin/brand-scraper/scrape/route.ts` and `src/app/api/admin/brand-scraper/jobs/[id]/route.ts` exist.

If ANY of these are missing, STOP execution immediately and report:
"Phase 20 (Brand Scraper API Proxy) has not been executed yet. Phase 21 depends on Phase 20 artifacts. Please run Phase 20 first."

Do NOT create these files -- they are Phase 20's responsibility.
  </action>
  <verify>
All three checks pass: `ls src/lib/brand-scraper/types.ts src/lib/brand-scraper/client.ts src/app/api/admin/brand-scraper/scrape/route.ts src/app/api/admin/brand-scraper/jobs/*/route.ts` returns all files.
  </verify>
  <done>Phase 20 artifacts confirmed to exist. Safe to proceed with Phase 21 implementation.</done>
</task>

<task type="auto">
  <name>Task 1: Install SWR and extend types with BrandTaxonomy schema</name>
  <files>package.json, src/lib/brand-scraper/types.ts</files>
  <action>
1. Install SWR:
   ```bash
   npm install swr
   ```

2. Open `src/lib/brand-scraper/types.ts` (created by Phase 20). It will have `scrapeRequestSchema`, `scrapeJobSubmissionSchema`, and `jobStatusSchema` with `result: z.unknown().optional()`.

3. Add a `brandTaxonomySchema` Zod object ABOVE the `jobStatusSchema` definition:

```typescript
export const brandTaxonomySchema = z.object({
  colors: z.array(z.object({
    hex: z.string(),
    rgb: z.object({ r: z.number(), g: z.number(), b: z.number() }).optional(),
    name: z.string().optional(),
    role: z.string().optional(),
    confidence: z.number(),
    needs_review: z.boolean().optional(),
  })).optional(),
  fonts: z.array(z.object({
    family: z.string(),
    weights: z.array(z.number()).optional(),
    usage: z.string().optional(),
    source: z.string().optional(),
    confidence: z.number(),
    needs_review: z.boolean().optional(),
  })).optional(),
  logos: z.array(z.object({
    url: z.string(),
    format: z.string().optional(),
    dimensions: z.object({ width: z.number(), height: z.number() }).optional(),
    confidence: z.number(),
    needs_review: z.boolean().optional(),
  })).optional(),
  assets: z.array(z.object({
    url: z.string(),
    type: z.string().optional(),
    format: z.string().optional(),
    confidence: z.number().optional(),
  })).optional(),
  identity: z.object({
    tagline: z.string().optional(),
    industry: z.string().optional(),
  }).optional(),
}).passthrough();
```

4. Export the inferred type: `export type BrandTaxonomy = z.infer<typeof brandTaxonomySchema>;`

5. Update `jobStatusSchema` to replace `result: z.unknown().optional()` with `result: brandTaxonomySchema.optional()`.

6. Re-export the `JobStatus` type so it now includes the typed `result` field.

IMPORTANT: Use `.passthrough()` on `brandTaxonomySchema` to tolerate unexpected extra fields from the API. The schema shape is a best guess (LOW confidence per research) and needs to be permissive.
  </action>
  <verify>
Run `npx tsc --noEmit` -- types.ts compiles with no errors. Verify that `BrandTaxonomy` type is exported alongside the existing types (`ScrapeRequest`, `ScrapeJobSubmission`, `JobStatus`).
  </verify>
  <done>SWR is installed in package.json. brandTaxonomySchema is defined with colors, fonts, logos, assets, identity sections (all optional arrays with confidence). jobStatusSchema.result is typed as BrandTaxonomy instead of unknown. BrandTaxonomy type is exported.</done>
</task>

<task type="auto">
  <name>Task 2: useJobStatus SWR hook with dynamic polling</name>
  <files>src/lib/brand-scraper/hooks.ts</files>
  <action>
Create `src/lib/brand-scraper/hooks.ts` as a `"use client"` module.

```typescript
"use client";

import { useCallback, useRef, useState } from "react";
import useSWR from "swr";
import type { JobStatus } from "@/lib/brand-scraper/types";
```

Constants:
- `TERMINAL_STATUSES = ["succeeded", "partial", "failed"]`
- `POLL_INTERVAL_MS = 3000` (3 seconds)
- `MAX_POLLS = 100` (5 minutes max at 3s intervals)

Export `useJobStatus(jobId: string | null, token: string | null)`:

1. State: `pollInterval` (starts at `POLL_INTERVAL_MS`), `pollCount` ref (track number of polls).

2. SWR key: `jobId && token ? /api/admin/brand-scraper/jobs/${jobId} : null` (null key = no request, SWR conditional fetching).

3. SWR fetcher: An inline function that receives the URL and calls `fetch(url, { headers: { Authorization: Bearer ${token} } })`. On non-ok response, throw Error with status. Parse JSON and return.

4. SWR options:
   - `refreshInterval: pollInterval` (dynamic -- set to 0 to stop)
   - `onSuccess(data)`: Increment pollCount. If `TERMINAL_STATUSES.includes(data.status)`, set `pollInterval` to 0 (stop polling). If `pollCount.current >= MAX_POLLS`, set `pollInterval` to 0 (timeout protection).
   - `revalidateOnFocus: false` (don't re-poll on tab focus)
   - `revalidateOnReconnect: false`

5. Derived state:
   - `isTerminal`: data exists and status is in TERMINAL_STATUSES
   - `isPolling`: pollInterval > 0 and jobId is not null
   - `isTimedOut`: pollCount.current >= MAX_POLLS and not terminal

6. `reset` callback: Reset pollInterval to POLL_INTERVAL_MS, pollCount to 0.

7. Return: `{ data, error, isLoading, isPolling, isTerminal, isTimedOut, reset }`

IMPORTANT: The auth token MUST be included in every poll request (admin-protected endpoint). Do NOT use a simple fetcher without the Authorization header. The token is passed as a parameter, not fetched inside the hook -- the parent component gets it from `useAuth()`.
  </action>
  <verify>
Run `npx tsc --noEmit` -- hooks.ts compiles. Verify the file exports `useJobStatus` and imports `JobStatus` from types.ts.
  </verify>
  <done>useJobStatus hook uses SWR with dynamic refreshInterval (3s), stops polling on terminal statuses (succeeded/partial/failed), stops after 100 polls (5-minute max), includes Bearer token in every request, returns data/error/isLoading/isPolling/isTerminal/isTimedOut/reset.</done>
</task>

<task type="auto">
  <name>Task 3: UrlSubmitForm, JobStatusIndicator, and BrandConfidenceBadge components</name>
  <files>src/components/admin/brand-scraper/UrlSubmitForm.tsx, src/components/admin/brand-scraper/JobStatusIndicator.tsx, src/components/admin/brand-scraper/BrandConfidenceBadge.tsx</files>
  <action>
**Create `src/components/admin/brand-scraper/BrandConfidenceBadge.tsx`:**

`"use client"` component. Maps numeric 0-1 confidence score to categorical visual.

```typescript
function scoreToCategoryLevel(score: number): "high" | "medium" | "low" {
  if (score >= 0.85) return "high";
  if (score >= 0.60) return "medium";
  return "low";
}
```

Use the SAME visual style as `src/components/assistant/ConfidenceBadge.tsx` (emerald/amber/red color tokens, pill badge with dot indicator). Do NOT import the existing ConfidenceBadge -- recreate the styles inline in this component because the existing one uses "High confidence"/"Medium confidence"/"Low confidence" text labels, whereas this one should show the numeric percentage (e.g., "92%"). This keeps both components independent.

Props: `{ score: number }`. Display: colored pill badge showing `${Math.round(score * 100)}%` with dot indicator matching the tier color.

Style map (same colors as existing ConfidenceBadge):
- high: `bg-emerald-50 text-emerald-700 border-emerald-200`
- medium: `bg-amber-50 text-amber-700 border-amber-200`
- low: `bg-red-50 text-red-600 border-red-200`

**Create `src/components/admin/brand-scraper/UrlSubmitForm.tsx`:**

`"use client"` component following the TutorialEditor form pattern.

Props: `{ onJobSubmitted: (job: ScrapeJobSubmission) => void }` where `ScrapeJobSubmission` is imported from `@/lib/brand-scraper/types`.

State: `url` (string), `submitting` (boolean), `error` (string | null).

Use `useAuth()` from `@/context/AuthContext` to get the user.

`handleSubmit(e: FormEvent)`:
- Prevent default, set submitting true, clear error.
- Get token via `await user?.getIdToken()`. If no token, show "Not authenticated." error and return.
- POST to `/api/admin/brand-scraper/scrape` with `{ url }` body and `Authorization: Bearer ${token}` header.
- On non-ok response: parse JSON, extract `error` field, set error state.
- On success: parse JSON as `ScrapeJobSubmission`, call `onJobSubmitted(job)`.
- Catch block: set error to "An unexpected error occurred."
- Finally: set submitting false.

Render:
- `<form>` with `onSubmit={handleSubmit}`
- URL input: `type="url"`, placeholder "https://example.com", required attribute, full width, using the same input styling as TutorialEditor (`rounded-lg border border-border px-3 py-2 shadow-sm transition-colors focus:border-gold focus:ring-1 focus:ring-gold`)
- Submit button: Use the `Button` component from `@/components/ui/Button` with variant `"primary"`, disabled when submitting, text "Scrape" / "Submitting..."
- Error display: red text below the form when error is non-null
- Layout: flex row with gap on sm+, stacked on mobile. Input takes flex-1, button is fixed width.

**Create `src/components/admin/brand-scraper/JobStatusIndicator.tsx`:**

`"use client"` component displaying the current job status with visual indicators.

Props: `{ status: string; isPolling: boolean; isTimedOut: boolean; error: string | null }`.

Status config map:
```typescript
const STATUS_CONFIG: Record<string, { label: string; colorClass: string; animate: boolean }> = {
  queued: { label: "Queued", colorClass: "text-text-tertiary", animate: true },
  processing: { label: "Analyzing", colorClass: "text-amber-600", animate: true },
  succeeded: { label: "Complete", colorClass: "text-emerald-600", animate: false },
  partial: { label: "Partial Results", colorClass: "text-amber-600", animate: false },
  failed: { label: "Failed", colorClass: "text-red-600", animate: false },
};
```

Render:
- A horizontal bar showing: status dot (colored, optionally pulsing via `animate-pulse` when `animate: true`) + status label text + "Polling..." indicator when `isPolling` is true.
- If `isTimedOut`: show "Job is taking longer than expected." message in amber text.
- If `error`: show error message in red text.
- Unknown statuses: fall back to displaying the raw status string in neutral color.
- Use Tailwind utility classes consistent with the project design system.
  </action>
  <verify>
Run `npx tsc --noEmit` -- all three component files compile. Run `npm run lint` -- no Biome errors. Verify each file has `"use client"` directive and proper exports.
  </verify>
  <done>BrandConfidenceBadge maps 0-1 score to emerald/amber/red pill with percentage text. UrlSubmitForm posts URL to scrape API with auth token and calls onJobSubmitted callback. JobStatusIndicator displays queued/processing/succeeded/partial/failed states with animated dots and timeout warning.</done>
</task>

</tasks>

<verification>
1. `npm install` succeeds and `swr` appears in package.json dependencies
2. `npx tsc --noEmit` passes with zero type errors across all new files
3. `npm run lint` passes with zero Biome errors
4. `npm run build` succeeds
5. `src/lib/brand-scraper/types.ts` exports `BrandTaxonomy` type and `brandTaxonomySchema`
6. `src/lib/brand-scraper/hooks.ts` exports `useJobStatus` with SWR polling
7. All three component files are `"use client"` and have named exports
8. UrlSubmitForm imports `useAuth` and includes Bearer token in fetch
9. useJobStatus includes Bearer token in SWR fetcher and stops polling on terminal states
</verification>

<success_criteria>
- Phase 20 prerequisite files verified to exist before any implementation
- SWR is installed and importable
- BrandTaxonomy Zod schema validates brand data with optional colors/fonts/logos/assets/identity sections
- JobStatus type includes typed `result: BrandTaxonomy` instead of `unknown`
- useJobStatus polls every 3s, stops on terminal states, stops after 5 minutes, includes auth token
- UrlSubmitForm submits URL with auth token and reports success/error
- JobStatusIndicator shows visual status with animated indicators for active states
- BrandConfidenceBadge converts 0-1 score to colored percentage badge
- All quality gates pass: tsc, lint, build
</success_criteria>

<output>
After completion, create `.planning/phases/21-brand-scraper-ui/21-01-SUMMARY.md`
</output>
