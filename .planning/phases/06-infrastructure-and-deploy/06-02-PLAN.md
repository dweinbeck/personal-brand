---
phase: 06-infrastructure-and-deploy
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - scripts/deploy.sh
  - .env.local.example
autonomous: false
user_setup:
  - service: gcp
    why: "Cloud Run hosting and Firestore access"
    env_vars:
      - name: GCP_PROJECT_ID
        source: "GCP Console -> Project selector -> copy project ID"
    dashboard_config:
      - task: "Enable Cloud Run API"
        location: "GCP Console -> APIs & Services -> Enable APIs -> Cloud Run Admin API"
      - task: "Enable Artifact Registry API"
        location: "GCP Console -> APIs & Services -> Enable APIs -> Artifact Registry API"
      - task: "Ensure Firestore is enabled in the project"
        location: "GCP Console -> Firestore -> (should already exist from Phase 4)"

must_haves:
  truths:
    - "User has a parameterized deploy script they can run with their GCP project ID"
    - "Deploy script creates least-privilege service account with only datastore.user role"
    - "Deploy script uses Artifact Registry (not legacy gcr.io)"
    - "No credentials are hardcoded in any file"
    - "Secret Manager is not needed because ADC handles authentication (documented in deploy script and .env.local.example)"
    - ".env.local.example documents all env vars needed for local and production"
  artifacts:
    - path: "scripts/deploy.sh"
      provides: "Complete GCP deployment automation"
      contains: "roles/datastore.user"
    - path: ".env.local.example"
      provides: "Documented env var template for local dev and production"
      contains: "FIREBASE_PROJECT_ID"
  key_links:
    - from: "scripts/deploy.sh"
      to: "Dockerfile"
      via: "docker build command references local Dockerfile"
      pattern: "docker build"
    - from: "scripts/deploy.sh"
      to: "Cloud Run"
      via: "gcloud run deploy with service account and port 3000"
      pattern: "gcloud run deploy"
---

<objective>
Create a parameterized deployment script and updated env var documentation so the user can deploy to GCP Cloud Run with a single command.

Purpose: The user needs a ready-to-run deploy script that handles Artifact Registry setup, service account creation, Docker image push, and Cloud Run deployment -- all with least-privilege security. This plan also consolidates the security audit (originally 06-03) since the security requirements are addressed by the Dockerfile (non-root user from 06-01) and this deploy script (dedicated service account, ADC, no credential exposure).
Output: Executable deploy.sh script and updated .env.local.example with clear documentation.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-infrastructure-and-deploy/06-RESEARCH.md
@.planning/phases/06-infrastructure-and-deploy/06-01-SUMMARY.md
@Dockerfile
@.env.local.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Deploy script and env var documentation</name>
  <files>scripts/deploy.sh, .env.local.example</files>
  <action>
    1. **Create `scripts/deploy.sh`** -- A parameterized bash script for full GCP deployment:

       ```bash
       #!/usr/bin/env bash
       set -euo pipefail

       # ============================================================
       # Deploy personal-brand to GCP Cloud Run
       # Usage: ./scripts/deploy.sh <GCP_PROJECT_ID> [REGION]
       # ============================================================

       PROJECT_ID="${1:?Usage: ./scripts/deploy.sh <GCP_PROJECT_ID> [REGION]}"
       REGION="${2:-us-central1}"
       SERVICE_NAME="personal-brand"
       REPO_NAME="personal-brand"
       IMAGE_NAME="site"
       SA_NAME="cloudrun-site"
       SA_EMAIL="${SA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com"
       IMAGE_URI="${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPO_NAME}/${IMAGE_NAME}:latest"

       echo "==> Deploying to project: ${PROJECT_ID}, region: ${REGION}"

       # 1. Set active project
       gcloud config set project "${PROJECT_ID}"

       # 2. Enable required APIs
       echo "==> Enabling APIs..."
       gcloud services enable \
         run.googleapis.com \
         artifactregistry.googleapis.com \
         secretmanager.googleapis.com

       # 3. Create Artifact Registry repository (idempotent)
       echo "==> Creating Artifact Registry repository..."
       gcloud artifacts repositories create "${REPO_NAME}" \
         --repository-format=docker \
         --location="${REGION}" \
         --description="Personal brand site Docker images" \
         2>/dev/null || echo "    Repository already exists."

       # 4. Configure Docker authentication
       echo "==> Configuring Docker auth..."
       gcloud auth configure-docker "${REGION}-docker.pkg.dev" --quiet

       # 5. Create dedicated service account (idempotent)
       echo "==> Creating service account..."
       gcloud iam service-accounts create "${SA_NAME}" \
         --display-name="Cloud Run Personal Brand Site" \
         2>/dev/null || echo "    Service account already exists."

       # 6. Grant Firestore access (least privilege -- datastore.user only)
       echo "==> Granting Firestore access..."
       gcloud projects add-iam-policy-binding "${PROJECT_ID}" \
         --member="serviceAccount:${SA_EMAIL}" \
         --role="roles/datastore.user" \
         --condition=None \
         --quiet

       # 7. Build Docker image
       echo "==> Building Docker image..."
       docker build -t "${IMAGE_URI}" .

       # 8. Push to Artifact Registry
       echo "==> Pushing image to Artifact Registry..."
       docker push "${IMAGE_URI}"

       # 9. Deploy to Cloud Run
       echo "==> Deploying to Cloud Run..."
       gcloud run deploy "${SERVICE_NAME}" \
         --image "${IMAGE_URI}" \
         --region "${REGION}" \
         --service-account "${SA_EMAIL}" \
         --port 3000 \
         --memory 512Mi \
         --cpu 1 \
         --min-instances 0 \
         --max-instances 3 \
         --set-env-vars "FIREBASE_PROJECT_ID=${PROJECT_ID}" \
         --allow-unauthenticated

       # NOTE: Secret Manager is NOT needed for this deployment.
       # firebase-admin uses Application Default Credentials (ADC) via the
       # Cloud Run service account, which has roles/datastore.user for Firestore.
       # No private keys or secrets need to be stored in Secret Manager.
       # If you need additional secrets in the future, use:
       #   gcloud secrets create MY_SECRET --data-file=-
       #   gcloud run deploy ... --update-secrets=MY_ENV_VAR=MY_SECRET:latest

       # 10. Print the service URL
       echo ""
       echo "==> Deployment complete!"
       gcloud run services describe "${SERVICE_NAME}" \
         --region "${REGION}" \
         --format="value(status.url)"
       ```

       Make the script executable: `chmod +x scripts/deploy.sh`

       Key security properties:
       - Dedicated service account (not default Compute Engine SA)
       - Only `roles/datastore.user` granted (least privilege)
       - No credentials passed as env vars or build args
       - ADC handles Firebase auth automatically via the service account
       - `FIREBASE_PROJECT_ID` is the only env var set (not a secret)

    2. **Update `.env.local.example`** -- Replace or update the existing file to document both local dev and production env vars:

       Read the current `.env.local.example` first, then update it to have two clear sections:

       ```
       # ===========================================
       # Local Development Environment Variables
       # ===========================================
       # Copy this file to .env.local and fill in values

       # --- Firebase (local development) ---
       # On Cloud Run, these are NOT needed -- ADC handles auth automatically.
       # For local dev, get these from Firebase Console -> Project Settings -> Service Accounts
       FIREBASE_PROJECT_ID=your-firebase-project-id
       FIREBASE_CLIENT_EMAIL=your-service-account@your-project.iam.gserviceaccount.com
       FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"

       # --- GitHub API (optional, for projects page) ---
       # Works without auth but may hit rate limits
       # GITHUB_TOKEN=ghp_your_token_here

       # ===========================================
       # Production (Cloud Run) Notes
       # ===========================================
       # On Cloud Run, firebase-admin uses Application Default Credentials (ADC).
       # The only env var set in Cloud Run is FIREBASE_PROJECT_ID.
       # The Cloud Run service account needs roles/datastore.user for Firestore access.
       # Secret Manager is NOT needed -- ADC handles all authentication.
       # See scripts/deploy.sh for the full deployment process.
       ```

       Preserve any existing env vars that are already in the file (like GITHUB_TOKEN if present). Add the production notes section.
  </action>
  <verify>
    - `ls -la scripts/deploy.sh` shows the file exists and is executable
    - `bash -n scripts/deploy.sh` validates script syntax (no errors)
    - `grep "roles/datastore.user" scripts/deploy.sh` confirms least-privilege role
    - `grep "service-account" scripts/deploy.sh` confirms dedicated SA usage
    - `grep -v "PRIVATE_KEY" scripts/deploy.sh` confirms no secrets in deploy script (only FIREBASE_PROJECT_ID)
    - `.env.local.example` contains both local dev and production documentation
    - `grep "K_SERVICE\|ADC\|applicationDefault" scripts/deploy.sh .env.local.example` shows ADC documentation
  </verify>
  <done>
    Executable deploy script exists at scripts/deploy.sh with parameterized GCP project ID, least-privilege service account, Artifact Registry, and Cloud Run deployment. .env.local.example documents both local and production env var requirements.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete infrastructure for GCP Cloud Run deployment:
    - Dockerfile with multi-stage build, non-root user, standalone output (from 06-01)
    - firebase.ts refactored to use ADC on Cloud Run, cert() locally (from 06-01)
    - Docker image verified under 150MB (from 06-01)
    - Parameterized deploy script at scripts/deploy.sh
    - Updated .env.local.example with local + production documentation

    Security audit summary (consolidated from planned 06-03):
    - Non-root container user (nextjs:nodejs, uid 1001)
    - Dedicated service account (cloudrun-site) with only roles/datastore.user
    - No credentials in code, env vars, or build args
    - ADC for Firebase auth (no private key needed on Cloud Run)
    - .dockerignore excludes .env*, .planning, .git
  </what-built>
  <how-to-verify>
    1. Review `scripts/deploy.sh` -- confirm it matches your GCP project expectations
    2. Review `Dockerfile` -- confirm the multi-stage build looks correct
    3. Review `src/lib/firebase.ts` -- confirm the dual-mode credential logic makes sense
    4. When ready to deploy, run: `./scripts/deploy.sh YOUR_GCP_PROJECT_ID`
    5. After deployment, visit the printed Cloud Run URL and verify the site loads
    6. Test the contact form to verify Firestore writes work via ADC
  </how-to-verify>
  <resume-signal>Type "approved" after reviewing the files and (optionally) deploying, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- scripts/deploy.sh exists, is executable, and passes bash syntax check
- Deploy script uses dedicated service account with only datastore.user role
- Deploy script uses Artifact Registry (pkg.dev, not gcr.io)
- No credentials hardcoded anywhere in the codebase
- .env.local.example clearly documents local vs production env var requirements
</verification>

<success_criteria>
1. scripts/deploy.sh is a valid, executable bash script that deploys to Cloud Run with one command
2. Service account has only roles/datastore.user (least privilege)
3. No credentials appear in code, deploy script, or Docker build args
4. .env.local.example documents all needed env vars for both local dev and production
5. User can run `./scripts/deploy.sh <PROJECT_ID>` to deploy
</success_criteria>

<output>
After completion, create `.planning/phases/06-infrastructure-and-deploy/06-02-SUMMARY.md`
</output>
