---
phase: 40.1-testing-feedback-fixes
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/billing/firestore.ts
  - src/app/api/admin/billing/users/consolidate/route.ts
  - src/components/admin/billing/AdminBillingPage.tsx
autonomous: true

must_haves:
  truths:
    - "The same email address cannot result in two separate billing user entries"
    - "Admin can consolidate duplicate billing users via the billing management UI"
    - "ensureBillingUser creates only one document per email, merging with any existing email-matched entry"
  artifacts:
    - path: "src/lib/billing/firestore.ts"
      provides: "Email-based deduplication in ensureBillingUser and a consolidateBillingUsers function"
      contains: "consolidateBillingUsers"
    - path: "src/app/api/admin/billing/users/consolidate/route.ts"
      provides: "POST endpoint for admin to consolidate duplicate users"
      exports: ["POST"]
    - path: "src/components/admin/billing/AdminBillingPage.tsx"
      provides: "Warning badge for duplicate emails and consolidate button"
      contains: "consolidate"
  key_links:
    - from: "src/components/admin/billing/AdminBillingPage.tsx"
      to: "/api/admin/billing/users/consolidate"
      via: "fetch POST call"
      pattern: "consolidate"
    - from: "src/lib/billing/firestore.ts"
      to: "billing_users Firestore collection"
      via: "email query for deduplication"
      pattern: "where.*email"
---

<objective>
Fix the billing duplicate user issue by adding deduplication logic to prevent future duplicates and providing an admin tool to consolidate existing duplicates.

Purpose: The same email (daniel.weinbeck@gmail.com) has two billing_users documents with different UIDs (likely from different Firebase Auth sign-in providers). This causes confusion in the billing admin view and inconsistent credit balances.
Output: (1) `ensureBillingUser` checks for existing email matches before creating new entries, (2) admin consolidation API endpoint, (3) admin UI shows warning + consolidate action for duplicate emails.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/lib/billing/firestore.ts
@src/lib/billing/types.ts
@src/app/api/admin/billing/users/route.ts
@src/components/admin/billing/AdminBillingPage.tsx
@src/lib/auth/admin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add email deduplication to ensureBillingUser and create consolidation function</name>
  <files>src/lib/billing/firestore.ts</files>
  <action>
  1. In `ensureBillingUser`, BEFORE the existing transaction that checks `snap.exists`, add a query to find existing billing_users with matching email:
     ```ts
     // Check if a billing user already exists with this email under a different UID
     const emailQuery = await billingUsersCol().where("email", "==", email).limit(1).get();
     if (!emailQuery.empty) {
       const existingDoc = emailQuery.docs[0];
       if (existingDoc.id !== uid) {
         // An entry already exists under a different UID.
         // Create an alias: store a document at the new UID pointing to the canonical UID,
         // but return the canonical user data.
         const canonicalUser = existingDoc.data() as BillingUser;
         // Optionally create a stub document at the new uid so the onSnapshot listener doesn't fail
         const newRef = billingUsersCol().doc(uid);
         const newSnap = await newRef.get();
         if (!newSnap.exists) {
           await newRef.set({
             uid,
             email,
             balanceCredits: canonicalUser.balanceCredits,
             createdAt: FieldValue.serverTimestamp(),
             updatedAt: FieldValue.serverTimestamp(),
             lifetimePurchasedCredits: canonicalUser.lifetimePurchasedCredits,
             lifetimeSpentCredits: canonicalUser.lifetimeSpentCredits,
             lifetimeCostToUsCents: canonicalUser.lifetimeCostToUsCents,
             canonicalUid: existingDoc.id,
           });
         }
         return canonicalUser;
       }
     }
     ```
     NOTE: Move the email query OUTSIDE the transaction (it's a read-only check). Keep the existing transaction for the uid-based create.

  2. Add a new exported function `consolidateBillingUsers`:
     ```ts
     export async function consolidateBillingUsers(
       keepUid: string,
       mergeUid: string,
     ): Promise<{ balanceAfter: number }> {
       const firestore = requireDb();
       const keepRef = billingUsersCol().doc(keepUid);
       const mergeRef = billingUsersCol().doc(mergeUid);

       return firestore.runTransaction(async (txn) => {
         const [keepSnap, mergeSnap] = await Promise.all([
           txn.get(keepRef),
           txn.get(mergeRef),
         ]);

         if (!keepSnap.exists) throw new Error(`Keep user ${keepUid} not found.`);
         if (!mergeSnap.exists) throw new Error(`Merge user ${mergeUid} not found.`);

         const keepUser = keepSnap.data() as BillingUser;
         const mergeUser = mergeSnap.data() as BillingUser;

         // Merge balances and lifetime stats
         const balanceAfter = keepUser.balanceCredits + mergeUser.balanceCredits;

         txn.update(keepRef, {
           balanceCredits: balanceAfter,
           lifetimePurchasedCredits: keepUser.lifetimePurchasedCredits + mergeUser.lifetimePurchasedCredits,
           lifetimeSpentCredits: keepUser.lifetimeSpentCredits + mergeUser.lifetimeSpentCredits,
           lifetimeCostToUsCents: keepUser.lifetimeCostToUsCents + mergeUser.lifetimeCostToUsCents,
           updatedAt: FieldValue.serverTimestamp(),
         });

         // Add a ledger entry recording the merge
         txn.set(ledgerCol(keepUid).doc(), {
           type: "admin_adjustment",
           deltaCredits: mergeUser.balanceCredits,
           reason: `Consolidated duplicate account ${mergeUid} (${mergeUser.email})`,
           createdAt: FieldValue.serverTimestamp(),
         });

         // Delete the duplicate document
         txn.delete(mergeRef);

         return { balanceAfter };
       });
     }
     ```

  3. Export `consolidateBillingUsers` from the module.
  </action>
  <verify>
  - `npm run lint` passes
  - `npm run build` passes (types are correct)
  - `consolidateBillingUsers` function exists and is exported
  </verify>
  <done>
  The billing firestore layer has email deduplication in ensureBillingUser and a consolidateBillingUsers function for admin use.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create admin consolidation endpoint and add UI warning for duplicates</name>
  <files>src/app/api/admin/billing/users/consolidate/route.ts, src/components/admin/billing/AdminBillingPage.tsx</files>
  <action>
  1. Create `src/app/api/admin/billing/users/consolidate/route.ts`:
     ```ts
     import { z } from "zod/v4";
     import { unauthorizedResponse, verifyAdmin } from "@/lib/auth/admin";
     import { consolidateBillingUsers } from "@/lib/billing/firestore";

     const consolidateSchema = z.object({
       keepUid: z.string().min(1),
       mergeUid: z.string().min(1),
     });

     export async function POST(request: Request) {
       const auth = await verifyAdmin(request);
       if (!auth.authorized) return unauthorizedResponse(auth);

       try {
         const body = await request.json();
         const parsed = consolidateSchema.safeParse(body);
         if (!parsed.success) {
           return Response.json(
             { error: "Invalid input.", details: parsed.error.issues },
             { status: 400 },
           );
         }

         if (parsed.data.keepUid === parsed.data.mergeUid) {
           return Response.json(
             { error: "Cannot consolidate a user with itself." },
             { status: 400 },
           );
         }

         const result = await consolidateBillingUsers(
           parsed.data.keepUid,
           parsed.data.mergeUid,
         );
         return Response.json(result);
       } catch (error) {
         console.error("POST /api/admin/billing/users/consolidate error:", error);
         return Response.json(
           { error: error instanceof Error ? error.message : "Consolidation failed." },
           { status: 500 },
         );
       }
     }
     ```

  2. In `AdminBillingPage.tsx`, update the `UsersTable` component:
     - Detect duplicate emails: group users by email and find emails with count > 1
     - For rows with duplicate emails, show a yellow warning badge: `<span className="ml-2 inline-flex items-center rounded-full bg-amber-100 px-2 py-0.5 text-xs font-medium text-amber-800">Duplicate</span>`
     - Add a "Consolidate" button next to each duplicate row that calls `POST /api/admin/billing/users/consolidate` with `keepUid` = the UID with more credits, `mergeUid` = the other UID
     - After successful consolidation, call `fetchData()` to refresh the table
     - Add the `fetchData` function as a prop to `UsersTable` or lift the consolidation logic to AdminBillingPage and pass a callback
     - Add `onConsolidate` prop to UsersTable: `onConsolidate: (keepUid: string, mergeUid: string) => Promise<void>`
     - Wire from AdminBillingPage:
       ```ts
       const handleConsolidate = async (keepUid: string, mergeUid: string) => {
         if (!user) return;
         if (!window.confirm("Consolidate duplicate billing users? This merges credits and deletes the duplicate entry.")) return;
         const token = await user.getIdToken();
         const res = await fetch("/api/admin/billing/users/consolidate", {
           method: "POST",
           headers: { Authorization: `Bearer ${token}`, "Content-Type": "application/json" },
           body: JSON.stringify({ keepUid, mergeUid }),
         });
         if (!res.ok) {
           const data = await res.json();
           setError(data.error || "Consolidation failed.");
           return;
         }
         await fetchData();
       };
       ```
  </action>
  <verify>
  - `npm run lint` passes
  - `npm run build` passes
  - Consolidation endpoint file exists at `src/app/api/admin/billing/users/consolidate/route.ts`
  - AdminBillingPage shows "Duplicate" badge for users with same email
  - AdminBillingPage has a Consolidate button for duplicate entries
  </verify>
  <done>
  Admin billing page highlights duplicate email entries and provides a Consolidate button to merge them. New users created via different auth providers with the same email are handled by the deduplication logic in ensureBillingUser.
  </done>
</task>

</tasks>

<verification>
- `npm run lint && npm run build && npm test` all pass
- ensureBillingUser checks for existing email match before creating
- consolidateBillingUsers merges credits and deletes duplicate atomically
- Admin billing page shows "Duplicate" badge and consolidation button
- API endpoint validates input and requires admin auth
</verification>

<success_criteria>
Duplicate billing users are preventable (email dedup on creation) and fixable (admin consolidation). The admin can see and resolve the current duplicate from the billing management page.
</success_criteria>

<output>
After completion, create `.planning/phases/40.1-testing-feedback-fixes-tasks-tooltips-view-persistence-envelopes-budget-editing-and-detail-page-research-assistant-permissions-crash-billing-duplicate-user/40.1-03-SUMMARY.md`
</output>
