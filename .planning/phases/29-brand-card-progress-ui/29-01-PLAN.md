---
phase: 29-brand-card-progress-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/brand-scraper/types.ts
  - src/lib/brand-scraper/fonts.ts
  - src/app/api/tools/brand-scraper/jobs/[id]/assets/zip/route.ts
autonomous: true

must_haves:
  truths:
    - "jobStatusSchema accepts pipeline_meta and assets_manifest fields from enriched backend response without safeParse failures"
    - "Old jobs without pipeline_meta or assets_manifest still pass safeParse (fields are optional/nullish)"
    - "useGoogleFont hook loads a Google Font dynamically and reports loaded/error state"
    - "POST /api/tools/brand-scraper/jobs/{id}/assets/zip requires authentication and returns 401 without a valid Bearer token"
    - "POST /api/tools/brand-scraper/jobs/{id}/assets/zip proxies to backend and returns the zip signed URL on success"
  artifacts:
    - path: "src/lib/brand-scraper/types.ts"
      provides: "Extended jobStatusSchema with pipeline_meta and assets_manifest"
      contains: "pipelineMetaSchema"
    - path: "src/lib/brand-scraper/fonts.ts"
      provides: "useGoogleFont hook and loadGoogleFont utility"
      exports: ["useGoogleFont", "loadGoogleFont"]
    - path: "src/app/api/tools/brand-scraper/jobs/[id]/assets/zip/route.ts"
      provides: "Authenticated proxy for on-demand zip creation"
      exports: ["POST"]
  key_links:
    - from: "src/lib/brand-scraper/types.ts"
      to: "Backend GET /jobs/:id response"
      via: "Zod schema validation in client.ts getScrapeJobStatus"
      pattern: "pipeline_meta.*nullish"
    - from: "src/app/api/tools/brand-scraper/jobs/[id]/assets/zip/route.ts"
      to: "Backend POST /jobs/:id/assets/zip"
      via: "fetch proxy with verifyUser auth gate"
      pattern: "verifyUser.*BRAND_SCRAPER_API_URL"
---

<objective>
Extend the data layer and API proxy to support Phase 28's enriched backend response.

Purpose: The existing jobStatusSchema only knows about job_id, status, result, error, brand_json_url, and assets_zip_url. Phase 28 added pipeline_meta (with progress events) and assets_manifest (with per-asset signed URLs) to the backend response. This plan extends the Zod schema to parse these new fields, creates a dynamic font loading utility for rendering brand descriptions in extracted fonts, and adds an authenticated proxy route for on-demand zip creation.

Output: Extended types.ts with new schemas, fonts.ts utility with useGoogleFont hook, and zip proxy route.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-brand-card-progress-ui/29-RESEARCH.md
@.planning/phases/28-scraper-service-backend/28-04-SUMMARY.md
@.planning/phases/27-apps-first-home-schema-alignment/27-03-SUMMARY.md
@src/lib/brand-scraper/types.ts
@src/lib/brand-scraper/client.ts
@src/lib/brand-scraper/hooks.ts
@src/lib/auth/user.ts
@src/app/api/tools/brand-scraper/jobs/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend jobStatusSchema with pipeline_meta and assets_manifest</name>
  <files>src/lib/brand-scraper/types.ts</files>
  <action>
Add three new Zod schemas to `src/lib/brand-scraper/types.ts` ABOVE the existing `jobStatusSchema`:

1. **progressEventSchema** — validates individual progress events from `pipeline_meta.events`:
   ```
   { type: string, timestamp: string, detail: z.record(string, unknown).optional() }
   ```
   Use `.passthrough()`.

2. **pipelineMetaSchema** — validates the `pipeline_meta` envelope:
   ```
   {
     stages: z.array(z.object({ stage: string, status: string, duration_ms: number }).passthrough()).optional(),
     pages_sampled: z.number().optional(),
     duration_ms: z.number().optional(),
     events: z.array(progressEventSchema).optional()
   }
   ```
   Use `.passthrough()`.

3. **assetManifestEntrySchema** — validates individual asset entries in `assets_manifest.assets`. IMPORTANT: use **snake_case** field names per Phase 28-04 decision:
   ```
   {
     category: string,
     filename: string,
     original_url: string,
     content_type: string,
     size_bytes: number,
     gcs_object_path: string,
     signed_url: string.optional()
   }
   ```
   Use `.passthrough()`.

4. **assetsManifestSchema** — validates the `assets_manifest` envelope. Use **snake_case** field names:
   ```
   {
     assets: z.array(assetManifestEntrySchema),
     total_count: number,
     total_size_bytes: number,
     created_at: string
   }
   ```
   Use `.passthrough()`.

Then update the existing `jobStatusSchema` to add two new **nullish** fields:
```
pipeline_meta: pipelineMetaSchema.nullish(),
assets_manifest: assetsManifestSchema.nullish(),
```

Export the new schemas and inferred types: `ProgressEvent`, `PipelineMeta`, `AssetManifestEntry`, `AssetsManifest`. Use `export type X = z.infer<typeof xSchema>`.

CRITICAL: All new top-level fields on jobStatusSchema MUST be `.nullish()` so old jobs (before Phase 28) still pass safeParse. The schema already uses `.passthrough()` at the top level.

Do NOT modify any existing schemas (brandTaxonomySchema, scrapeRequestSchema, etc.). Only ADD new schemas and extend jobStatusSchema.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero type errors. Run `npm run lint` — clean. Run `npm run test` — all tests pass. Verify by reading types.ts that pipelineMetaSchema and assetsManifestSchema exist with snake_case fields, and jobStatusSchema includes both as nullish.
  </verify>
  <done>jobStatusSchema parses enriched backend responses with pipeline_meta and assets_manifest, and still parses old responses missing those fields.</done>
</task>

<task type="auto">
  <name>Task 2: Create dynamic Google Font loading utility</name>
  <files>src/lib/brand-scraper/fonts.ts</files>
  <action>
Create `src/lib/brand-scraper/fonts.ts` with two exports:

1. **`loadGoogleFont(family: string, weight?: string): Promise<boolean>`** — async utility function:
   - Construct Google Fonts CSS2 API URL: `https://fonts.googleapis.com/css2?family=${encodeURIComponent(family)}:wght@${weight}&display=swap` (default weight "400")
   - Fetch the CSS text
   - Extract the woff2 URL using regex: `/url\(([^)]+\.woff2[^)]*)\)/`
   - Create a `new FontFace(family, ...)` with the woff2 URL, load it, add to `document.fonts`
   - Return `true` on success, `false` on any error (best-effort, non-fatal)
   - Wrap entire function in try/catch returning `false`

2. **`useGoogleFont(family: string | null, weight?: string): { loaded: boolean; error: boolean }`** — React hook:
   - If `family` is null, return `{ loaded: false, error: false }` immediately
   - In `useEffect`, check if font is already loaded via `document.fonts.check(`16px "${family}"`)` — if so, set loaded=true and return
   - Otherwise call `loadGoogleFont(family, weight)`
   - Track `loaded` and `error` states
   - Use a `cancelled` flag in the cleanup function to prevent state updates after unmount
   - Dependencies: `[family, weight]`

Add `"use client"` directive at the top since this uses browser APIs (FontFace, document.fonts) and React hooks.

This file should be ~60-70 lines. Keep it focused — no UI rendering, just the utility and hook.
  </action>
  <verify>
Run `npx tsc --noEmit` — zero type errors. Run `npm run lint` — clean. Verify the file exports both `loadGoogleFont` and `useGoogleFont`.
  </verify>
  <done>fonts.ts exports a useGoogleFont hook that dynamically loads Google Fonts via the CSS Font Loading API with best-effort error handling.</done>
</task>

<task type="auto">
  <name>Task 3: Create authenticated zip proxy route</name>
  <files>src/app/api/tools/brand-scraper/jobs/[id]/assets/zip/route.ts</files>
  <action>
Create `src/app/api/tools/brand-scraper/jobs/[id]/assets/zip/route.ts` as a Next.js App Router API route.

Export a `POST` handler that:

1. Calls `verifyUser(request)` from `@/lib/auth/user` — return `unauthorizedResponse(auth)` if not authorized.
2. Awaits `params` to get the job `id` (same pattern as existing `jobs/[id]/route.ts`): `const { id } = await params;`
3. Reads `BRAND_SCRAPER_API_URL` from `process.env`. If not set, return 503 with error message.
4. Proxies to `${BRAND_SCRAPER_API_URL}/jobs/${id}/assets/zip` with:
   - Method: POST
   - Signal: `AbortSignal.timeout(60_000)` (zip creation can take time)
   - No body (the backend needs no request body for zip creation)
5. If backend response is not OK:
   - Try to parse JSON body for error message
   - Return `Response.json({ error: body?.error ?? "Zip creation failed (status)" }, { status: res.status })`
6. If backend response is OK:
   - Return `Response.json(await res.json())`
7. Wrap the fetch in try/catch for network errors — return 503 on timeout/network failure.

Follow the exact same auth pattern as `src/app/api/tools/brand-scraper/jobs/[id]/route.ts`. Import `verifyUser` and `unauthorizedResponse` from `@/lib/auth/user`.

This route satisfies ASST-05: "Main site proxy route for on-demand zip with auth gating".
  </action>
  <verify>
Run `npx tsc --noEmit` — zero type errors. Run `npm run lint` — clean. Verify the route file exists and exports POST. Verify it imports verifyUser and has auth check before proxying.
  </verify>
  <done>POST /api/tools/brand-scraper/jobs/{id}/assets/zip requires authentication and proxies to the backend zip endpoint, returning 401 for unauthenticated requests and the zip signed URL for authenticated ones.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run lint` passes clean
3. `npm run test` — all existing tests still pass
4. types.ts: `jobStatusSchema` includes `pipeline_meta` and `assets_manifest` as nullish fields
5. fonts.ts: exports `useGoogleFont` and `loadGoogleFont`
6. zip/route.ts: exports POST function with verifyUser auth check
</verification>

<success_criteria>
- Extended Zod schemas parse Phase 28 enriched responses with snake_case fields
- Old jobs without pipeline_meta/assets_manifest still validate
- Font loading utility uses CSS Font Loading API with best-effort semantics
- Zip proxy route is auth-gated and proxies to backend
- All quality gates pass (types, lint, tests)
</success_criteria>

<output>
After completion, create `.planning/phases/29-brand-card-progress-ui/29-01-SUMMARY.md`
</output>
