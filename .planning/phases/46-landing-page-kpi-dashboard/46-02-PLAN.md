---
phase: 46-landing-page-kpi-dashboard
plan: 02
type: execute
wave: 2
depends_on: [46-01]
files_modified:
  - src/services/tasks/task.service.ts
  - src/app/apps/tasks/page.tsx
autonomous: true
requirements: [LP-04, LP-07]

must_haves:
  truths:
    - "KPI card column 1 shows live 'Tasks completed yesterday' count from PostgreSQL"
    - "KPI card column 1 shows live 'Current Total Tasks' count from PostgreSQL"
    - "KPI card column 2 shows the user's MIT-tagged task fetched from database"
    - "KPI card column 3 shows up to two Next-tagged tasks fetched from database"
    - "Unauthenticated users do not see KPI data (layout AuthGuard handles sign-in prompt)"
  artifacts:
    - path: "src/services/tasks/task.service.ts"
      provides: "KPI data query functions for completed count, total count, MIT task, Next tasks"
      exports: ["getCompletedYesterdayCount", "getTotalTaskCount", "getMitTask", "getNextTasks"]
    - path: "src/app/apps/tasks/page.tsx"
      provides: "Landing page with live KPI data from database"
      contains: "getCompletedYesterdayCount|getTotalTaskCount|getMitTask|getNextTasks"
  key_links:
    - from: "src/app/apps/tasks/page.tsx"
      to: "src/services/tasks/task.service.ts"
      via: "server-side import and await"
      pattern: "await.*(getCompletedYesterdayCount|getTotalTaskCount|getMitTask|getNextTasks)"
    - from: "src/services/tasks/task.service.ts"
      to: "prisma.task"
      via: "Prisma query"
      pattern: "prisma\\.task\\.(count|findFirst|findMany)"
    - from: "src/services/tasks/task.service.ts"
      to: "prisma.tag"
      via: "Prisma tag lookup"
      pattern: "prisma\\.tag\\.findFirst"
---

<objective>
Add KPI data-fetching service functions and wire live PostgreSQL data into the Tasks landing page. The KPI card shows real counts and tagged tasks for authenticated users.

Purpose: The "Your Tasks at a Glance" dashboard shows meaningful, personalized data — completed yesterday count, total task count, MIT-tagged task, and Next-tagged tasks — all fetched live from the database.
Output: Four new service functions in task.service.ts, page.tsx updated to call them and pass real data to TasksKpiCard.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/46-landing-page-kpi-dashboard/46-01-SUMMARY.md
@src/services/tasks/task.service.ts
@src/services/tasks/tag.service.ts
@src/lib/tasks/auth.ts
@src/lib/prisma.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add KPI query functions to task.service.ts</name>
  <files>src/services/tasks/task.service.ts</files>
  <action>
Add four new exported async functions to the existing `src/services/tasks/task.service.ts` file. Append them at the end of the file (do NOT modify existing functions).

**1. `getCompletedYesterdayCount(userId: string): Promise<number>`**

Count tasks where:
- `userId` matches
- `status === "COMPLETED"`
- `updatedAt >= yesterday start-of-day AND updatedAt < today start-of-day`
- `parentTaskId === null` (only top-level tasks, not subtasks)

Use `prisma.task.count()` with these where conditions. Calculate yesterday's start as:
```typescript
const now = new Date();
const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
const yesterdayStart = new Date(todayStart);
yesterdayStart.setDate(yesterdayStart.getDate() - 1);
```

**2. `getTotalTaskCount(userId: string): Promise<number>`**

Count all tasks where:
- `userId` matches
- `status === "OPEN"` (only open/active tasks, not completed)
- `parentTaskId === null` (only top-level tasks)

Use `prisma.task.count()`.

**3. `getMitTask(userId: string): Promise<{ id: string; name: string; projectName: string | null } | null>`**

Find the first open task tagged with "MIT":
- First, find the tag: `prisma.tag.findFirst({ where: { userId, name: "MIT" } })`
- If no MIT tag exists, return null
- Then find the first open task with that tag: `prisma.task.findFirst({ where: { userId, status: "OPEN", parentTaskId: null, tags: { some: { tagId: mitTag.id } } }, include: { project: { select: { name: true } } }, orderBy: { updatedAt: "desc" } })`
- Return `{ id: task.id, name: task.name, projectName: task.project.name }` or null if not found

**4. `getNextTasks(userId: string): Promise<{ id: string; name: string; projectName: string | null }[]>`**

Find up to 2 open tasks tagged with "Next":
- First, find the tag: `prisma.tag.findFirst({ where: { userId, name: "Next" } })`
- If no Next tag exists, return empty array
- Then find up to 2 tasks: `prisma.task.findMany({ where: { userId, status: "OPEN", parentTaskId: null, tags: { some: { tagId: nextTag.id } } }, include: { project: { select: { name: true } } }, orderBy: { updatedAt: "desc" }, take: 2 })`
- Map to `{ id, name, projectName: task.project.name }`

**Important:** Import `prisma` from `@/lib/prisma` (already imported at top of file). These functions follow the same pattern as existing functions in the file (like `getCompletedTasks`, `getTasksForToday`).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify type checking passes.
Run `npm run lint` to verify no lint errors.
  </verify>
  <done>
Four new functions exported from task.service.ts: getCompletedYesterdayCount, getTotalTaskCount, getMitTask, getNextTasks. All type-check and follow existing service patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire live KPI data into the landing page</name>
  <files>src/app/apps/tasks/page.tsx</files>
  <action>
Update `src/app/apps/tasks/page.tsx` to replace the placeholder KPI data from Plan 01 with live database queries.

**1. Add imports** for the new service functions:
```typescript
import {
  getCompletedYesterdayCount,
  getTotalTaskCount,
  getMitTask,
  getNextTasks,
} from "@/services/tasks/task.service";
```

**2. Fetch KPI data** inside the server component, only when `userId` exists. Use `Promise.all` for parallel fetching:

```typescript
const userId = await getUserIdFromCookie();

// Only fetch KPI data for authenticated users
let kpiData = null;
if (userId) {
  const [completedYesterday, totalTasks, mitTask, nextTasks, workspaces] =
    await Promise.all([
      getCompletedYesterdayCount(userId),
      getTotalTaskCount(userId),
      getMitTask(userId),
      getNextTasks(userId),
      getWorkspaces(userId),
    ]);

  kpiData = { completedYesterday, totalTasks, mitTask, nextTasks };
  // Use workspaces for the hasWorkspaces check
}
```

**3. Update the JSX** to pass real data to TasksKpiCard:

```tsx
{kpiData && (
  <TasksKpiCard
    completedYesterday={kpiData.completedYesterday}
    totalTasks={kpiData.totalTasks}
    mitTask={kpiData.mitTask}
    nextTasks={kpiData.nextTasks}
  />
)}
```

**4. Auth handling:** The layout.tsx already wraps with `AuthGuard` which shows a sign-in prompt for unauthenticated users. The page should still show the title and subtitle for all users, but only show the KPI card when authenticated. When `userId` is null:
- Show the title and subtitle (always visible)
- Do NOT show the KPI card (no data to show)
- Do NOT redirect anywhere (remove the `redirect("/")` if it still exists from Plan 01)
- The layout's AuthGuard handles the sign-in prompt wrapping

**5. Remove the `redirect` import** from `next/navigation` if no longer used.

The final page flow:
- getUserIdFromCookie() -> userId or null
- If userId: fetch KPI data + workspaces in parallel, render title + subtitle + KPI card + empty workspace prompt
- If no userId: render title + subtitle only (AuthGuard in layout handles the rest)
  </action>
  <verify>
Run `npm run build` to verify the full build passes.
Run `npm run lint` to verify no lint errors.
  </verify>
  <done>
The /apps/tasks landing page fetches live KPI data (completed yesterday count, total tasks, MIT task, Next tasks) from PostgreSQL for authenticated users. Unauthenticated users see the title and subtitle only (AuthGuard handles sign-in prompt). Build and lint pass cleanly.
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- `npm run lint` passes
- Authenticated user sees KPI card with live data from database
- Unauthenticated user does not see KPI data (AuthGuard shows sign-in prompt)
- KPI card column 1 shows real completed yesterday count and total task count
- KPI card column 2 shows the MIT-tagged task from the database
- KPI card column 3 shows up to two Next-tagged tasks from the database
</verification>

<success_criteria>
1. getCompletedYesterdayCount returns count of tasks completed yesterday (status=COMPLETED, updatedAt in yesterday range)
2. getTotalTaskCount returns count of open top-level tasks
3. getMitTask returns the first open task tagged "MIT" with project name
4. getNextTasks returns up to 2 open tasks tagged "Next" with project names
5. Landing page calls all four functions via Promise.all for authenticated users
6. Unauthenticated users see title/subtitle but no KPI card (layout AuthGuard handles sign-in)
7. Build and lint pass cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/46-landing-page-kpi-dashboard/46-02-SUMMARY.md`
</output>
