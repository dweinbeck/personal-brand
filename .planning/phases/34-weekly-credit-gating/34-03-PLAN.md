---
phase: 34-weekly-credit-gating
plan: 03
type: execute
wave: 2
depends_on: ["34-01"]
files_modified:
  - src/data/apps.ts
  - src/app/sitemap.ts
  - src/lib/billing/__tests__/credits.test.ts
  - src/lib/billing/__tests__/tasks-access.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tasks app appears on /apps page with correct metadata"
    - "Sitemap includes tasks app URL"
    - "Unit tests verify tasks_app tool pricing entry exists and is active"
    - "Unit tests verify checkTasksAccess logic (free week, paid week, insufficient credits)"
  artifacts:
    - path: "src/data/apps.ts"
      provides: "Tasks app listing entry"
      contains: "tasks"
    - path: "src/app/sitemap.ts"
      provides: "Tasks app sitemap entry"
      contains: "tasks"
    - path: "src/lib/billing/__tests__/tasks-access.test.ts"
      provides: "Unit tests for checkTasksAccess logic"
      contains: "checkTasksAccess"
    - path: "src/lib/billing/__tests__/credits.test.ts"
      provides: "Updated tool pricing tests including tasks_app"
      contains: "tasks_app"
  key_links:
    - from: "src/data/apps.ts"
      to: "/apps page"
      via: "getApps() includes tasks entry"
      pattern: "slug.*tasks"
---

<objective>
Add the tasks app to the apps hub, update the sitemap, and create billing unit tests.

Purpose: Makes the tasks app discoverable on the /apps page and verifies billing logic with automated tests.
Output: Apps hub entry, sitemap entry, tool pricing tests, and access check tests.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-weekly-credit-gating/34-RESEARCH.md
@.planning/phases/34-weekly-credit-gating/34-01-SUMMARY.md

Repo: personal-brand at /Users/dweinbeck/Documents/personal-brand

Reference:
@src/data/apps.ts (add tasks entry)
@src/app/sitemap.ts (add tasks URL)
@src/lib/billing/__tests__/credits.test.ts (extend with tasks_app tests)
@src/lib/billing/tasks.ts (test target -- created in 34-01)
@src/lib/billing/tools.ts (TOOL_PRICING_SEED with tasks_app)
@src/lib/envelopes/billing.ts (logic pattern that tasks.ts mirrors)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Apps hub entry and sitemap update</name>
  <files>src/data/apps.ts, src/app/sitemap.ts</files>
  <action>
**1. Update `src/data/apps.ts`:**

Add a new entry to the `getApps()` return array, after the envelopes entry:

```typescript
{
  slug: "tasks",
  title: "Task Manager",
  tag: "Productivity",
  subtitle: "Organize projects, tasks, and tags",
  description:
    "Full-featured task management with workspaces, projects, sections, tags, subtasks, effort scoring, and board views. Built with a standalone PostgreSQL backend.",
  href: process.env.TASKS_APP_URL || "https://todoist-app.run.app",
  launchedAt: "2026-02-12",
  updatedAt: "2026-02-12",
  techStack: ["Next.js", "PostgreSQL", "Prisma", "Firebase Auth"],
  available: true,
},
```

Note: `href` uses `process.env.TASKS_APP_URL` so the deployed URL can be configured via environment variable. The fallback is a placeholder that will be updated when the todoist Cloud Run service URL is known.

**2. Update `src/app/sitemap.ts`:**

Add a new entry to the static pages array, after the brand-scraper entry:

```typescript
{
  url: `${BASE_URL}/apps/tasks`,
  lastModified: now,
  changeFrequency: "monthly",
  priority: 0.6,
},
```

Wait -- tasks app is an external link, not a page on personal-brand. The sitemap should NOT include the external todoist URL. Instead, the /apps page already has a sitemap entry at priority 0.7. No sitemap change needed for an external app link.

Actually, re-check: the brand-scraper app IS on personal-brand (`/apps/brand-scraper`) so it has a sitemap entry. The tasks app is external. Do NOT add a tasks-specific sitemap entry. The `/apps` page entry already covers discoverability.

Correction: Do NOT modify `src/app/sitemap.ts`. The tasks app is external, not hosted on personal-brand. The existing `/apps` sitemap entry is sufficient.
  </action>
  <verify>
Run `npm run build` in /Users/dweinbeck/Documents/personal-brand. Run `npm run lint`. All pass. The apps page now shows 3 entries.
  </verify>
  <done>
Tasks app entry exists in `getApps()` with slug "tasks", correct metadata, and `available: true`. Sitemap unchanged (external app).
  </done>
</task>

<task type="auto">
  <name>Task 2: Billing unit tests for tasks_app pricing and access logic</name>
  <files>src/lib/billing/__tests__/credits.test.ts, src/lib/billing/__tests__/tasks-access.test.ts</files>
  <action>
**1. Update `src/lib/billing/__tests__/credits.test.ts`:**

The existing test "active tools are marked active" checks `["brand_scraper", "dave_ramsey"]`. Update it to include `"tasks_app"`:
```
const activeKeys = ["brand_scraper", "dave_ramsey", "tasks_app"];
```

The existing test "placeholder tools are inactive" uses the same set to filter. Update:
```
const activeKeys = new Set(["brand_scraper", "dave_ramsey", "tasks_app"]);
```

Add a new test in the "Tool pricing seed" describe block:
```
it("tasks_app is priced at 100 credits (weekly)", () => {
  const tasks = TOOL_PRICING_SEED.find((t) => t.toolKey === "tasks_app");
  expect(tasks).toBeDefined();
  expect(tasks?.active).toBe(true);
  expect(tasks?.creditsPerUse).toBe(100);
  expect(tasks?.costToUsCentsEstimate).toBe(0);
});
```

**2. Create `src/lib/billing/__tests__/tasks-access.test.ts`:**

Test the `checkTasksAccess` function logic using mocks. Since `checkTasksAccess` depends on Firestore and `debitForToolUse`, mock those dependencies:

```typescript
import { describe, expect, it, vi, beforeEach } from "vitest";
```

Mock `@/lib/firebase` to provide a fake db with `collection().doc()` and `runTransaction()`:
```typescript
vi.mock("@/lib/firebase", () => ({ db: mockDb }));
vi.mock("@/lib/billing/firestore", () => ({ debitForToolUse: mockDebit }));
```

Create a `mockDb` object that simulates Firestore:
- `collection("tasks_billing").doc(uid)` returns a ref
- `runTransaction(fn)` calls fn with a mock txn
- Mock txn has `get(ref)` and `set(ref, data)`

Then `import { checkTasksAccess } from "../tasks"` AFTER vi.mock calls.

Test cases (in a describe "checkTasksAccess"):

a. **"returns readwrite with free_week reason for first-ever access"**
   - Mock: transaction get returns `{ exists: false }` (no billing doc yet)
   - Expect: `{ mode: "readwrite", weekStart: expect.any(String), reason: "free_week" }`
   - The function creates the billing doc with `firstAccessWeekStart` = current week, so the free week check matches

b. **"returns readwrite for already-paid week"**
   - Mock: transaction get returns `{ exists: true, data: () => ({ uid, firstAccessWeekStart: "2025-01-01", paidWeeks: { [currentWeekStart]: { usageId: "x", creditsCharged: 100, chargedAt: {} } } }) }`
   - Expect: `{ mode: "readwrite", weekStart: currentWeekStart }`
   - No `reason` field (not free week, just already paid)

c. **"returns readwrite after successful charge"**
   - Mock: transaction get returns existing doc with different firstAccessWeekStart and empty paidWeeks for current week
   - Mock: `debitForToolUse` resolves with `{ usageId: "new", creditsCharged: 100 }`
   - Also mock `collection().doc().update()` to succeed
   - Expect: `{ mode: "readwrite", weekStart: currentWeekStart }`

d. **"returns readonly with unpaid reason when credits insufficient"**
   - Mock: same as (c) but `debitForToolUse` throws an Error with `statusCode: 402`
   - Expect: `{ mode: "readonly", weekStart: currentWeekStart, reason: "unpaid" }`

e. **"returns readonly when tool config is missing"**
   - Mock: `debitForToolUse` throws `new Error("Unknown tool: tasks_app")`
   - Expect: `{ mode: "readonly", weekStart: currentWeekStart, reason: "unpaid" }`

f. **"uses correct idempotency key format"**
   - Mock: same as (c), verify `debitForToolUse` was called with `{ toolKey: "tasks_app", idempotencyKey: expect.stringMatching(/^tasks_week_\d{4}-\d{2}-\d{2}$/) }`

Use `date-fns` `format` and `startOfWeek` to compute the expected `currentWeekStart` in tests so assertions match.

Keep tests focused on the pure logic flow. The Firestore mocking can be simple -- we just need to verify the decision tree (free week -> already paid -> charge -> 402 -> tool error).
  </action>
  <verify>
Run `npm test` in /Users/dweinbeck/Documents/personal-brand -- all tests pass including new tasks-access tests.
Run `npm run build` and `npm run lint` -- both pass.
  </verify>
  <done>
Tool pricing tests updated to include tasks_app. New `tasks-access.test.ts` covers all 6 decision paths: free week, already paid, successful charge, insufficient credits, tool config error, and idempotency key format. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npm test` passes -- all billing tests green including new tasks-access tests
2. `npm run build` passes
3. `npm run lint` passes
4. `getApps()` returns 3 entries (brand-scraper, envelopes, tasks)
5. tasks_app tool pricing assertions pass (100 credits, active)
6. All 6 access check decision paths tested
</verification>

<success_criteria>
- Tasks app visible on /apps page with title "Task Manager", tag "Productivity", and correct tech stack
- Tool pricing seed tests include tasks_app and all pass
- Access check unit tests cover free week, paid week, charge success, 402, tool error, and idempotency key
- All quality gates pass (build, lint, test)
</success_criteria>

<output>
After completion, create `.planning/phases/34-weekly-credit-gating/34-03-SUMMARY.md`
</output>
