---
phase: 34-weekly-credit-gating
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/billing/tasks.ts
  - src/lib/billing/tools.ts
  - src/app/api/billing/tasks/access/route.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GET /api/billing/tasks/access returns {mode, reason, weekStart} for authenticated user"
    - "First-ever access returns mode:readwrite with reason:free_week"
    - "Already-paid week returns mode:readwrite without reason"
    - "Insufficient credits returns mode:readonly with reason:unpaid"
    - "tasks_app pricing entry exists in TOOL_PRICING_SEED at 100 credits"
  artifacts:
    - path: "src/lib/billing/tasks.ts"
      provides: "checkTasksAccess() function mirroring checkEnvelopeAccess()"
      contains: "checkTasksAccess"
    - path: "src/app/api/billing/tasks/access/route.ts"
      provides: "GET endpoint for cross-service billing check"
      exports: ["GET"]
    - path: "src/lib/billing/tools.ts"
      provides: "tasks_app tool pricing seed entry"
      contains: "tasks_app"
  key_links:
    - from: "src/app/api/billing/tasks/access/route.ts"
      to: "src/lib/billing/tasks.ts"
      via: "import checkTasksAccess"
      pattern: "checkTasksAccess"
    - from: "src/lib/billing/tasks.ts"
      to: "src/lib/billing/firestore.ts"
      via: "debitForToolUse"
      pattern: "debitForToolUse"
---

<objective>
Create the billing API for tasks app weekly credit gating in the personal-brand repo.

Purpose: Provides the billing endpoint that the todoist repo will call server-to-server to determine whether a user has readwrite or readonly access for the current week.
Output: `checkTasksAccess()` function, `GET /api/billing/tasks/access` route, and `tasks_app` tool pricing seed entry.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-weekly-credit-gating/34-RESEARCH.md

Repo: personal-brand at /Users/dweinbeck/Documents/personal-brand

Reference implementations (read these before coding):
@src/lib/envelopes/billing.ts (exact pattern to mirror for checkTasksAccess)
@src/lib/envelopes/types.ts (EnvelopeBilling/EnvelopeAccessResult types to mirror)
@src/lib/billing/tools.ts (add tasks_app entry here)
@src/lib/billing/firestore.ts (debitForToolUse import)
@src/app/api/envelopes/route.ts (API route pattern for billing check)
@src/lib/auth/user.ts (verifyUser + unauthorizedResponse for API route)
</context>

<tasks>

<task type="auto">
  <name>Task 1: checkTasksAccess function and types</name>
  <files>src/lib/billing/tasks.ts, src/lib/billing/tools.ts</files>
  <action>
Create `src/lib/billing/tasks.ts` mirroring the exact structure of `src/lib/envelopes/billing.ts`:

1. Define types at the top of the file (inline, not a separate types file -- keep it simple):
   - `TasksBilling`: `{ uid, firstAccessWeekStart, paidWeeks: Record<string, { usageId, creditsCharged, chargedAt }>, createdAt, updatedAt }` (mirrors `EnvelopeBilling`)
   - `TasksAccessResult`: discriminated union with `{ mode: "readwrite"; weekStart: string; reason?: "free_week" }` | `{ mode: "readonly"; weekStart: string; reason: "unpaid" }` (mirrors `EnvelopeAccessResult`)

2. Constants: `WEEK_OPTIONS = { weekStartsOn: 0 as const }`, `TASKS_TOOL_KEY = "tasks_app"`

3. Collection helper: `tasksBillingCol()` returning `db.collection("tasks_billing")` with null check on db

4. `checkTasksAccess(uid: string, email: string): Promise<TasksAccessResult>` -- copy the logic from `checkEnvelopeAccess()` exactly:
   - Calculate `currentWeekStart` using `format(startOfWeek(new Date(), WEEK_OPTIONS), "yyyy-MM-dd")`
   - Step 1: Get-or-create billing doc in Firestore transaction (`tasks_billing/{uid}`)
   - Step 2: Free week check (`firstAccessWeekStart === currentWeekStart` -> readwrite with reason `free_week`)
   - Step 3: Already-paid check (`paidWeeks[currentWeekStart]` exists -> readwrite)
   - Step 4: Attempt charge via `debitForToolUse({ uid, email, toolKey: TASKS_TOOL_KEY, idempotencyKey: tasks_week_${currentWeekStart} })`
   - Step 5: On 402 error -> readonly with reason `unpaid`
   - Step 6: On tool config error (unknown tool / not active) -> readonly with reason `unpaid` + console.warn
   - Step 7: Other errors -> re-throw

Imports: `format` and `startOfWeek` from `date-fns`, `FieldValue` from `firebase-admin/firestore`, `debitForToolUse` from `@/lib/billing/firestore`, `db` from `@/lib/firebase`.

Then update `src/lib/billing/tools.ts`:
- Add `tasks_app` entry to the `TOOL_PRICING_SEED` array: `{ toolKey: "tasks_app", label: "Task Manager (Weekly)", active: true, creditsPerUse: 100, costToUsCentsEstimate: 0 }`
- Place it after the `dave_ramsey` entry
  </action>
  <verify>
Run `npm run build` in /Users/dweinbeck/Documents/personal-brand -- no TypeScript errors. Grep for `checkTasksAccess` and `tasks_app` in the output files.
  </verify>
  <done>
`src/lib/billing/tasks.ts` exports `checkTasksAccess()` with identical logic flow to `checkEnvelopeAccess()`. `TOOL_PRICING_SEED` in tools.ts includes `tasks_app` at 100 credits, active: true.
  </done>
</task>

<task type="auto">
  <name>Task 2: Billing access API route</name>
  <files>src/app/api/billing/tasks/access/route.ts</files>
  <action>
Create `src/app/api/billing/tasks/access/route.ts` with a single GET handler:

```
import { unauthorizedResponse, verifyUser } from "@/lib/auth/user";
import { checkTasksAccess } from "@/lib/billing/tasks";
```

GET handler:
1. `const auth = await verifyUser(request);`
2. `if (!auth.authorized) return unauthorizedResponse(auth);`
3. Try/catch block:
   - Call `checkTasksAccess(auth.uid, auth.email)`
   - Return `Response.json({ mode: access.mode, reason: "reason" in access ? access.reason : undefined, weekStart: access.weekStart })`
   - On error: `console.error("GET /api/billing/tasks/access error:", error)` and return 500 with `{ error: "Failed to check tasks access." }`

This is the endpoint that the todoist repo will call cross-service with `Authorization: Bearer <idToken>`.

No POST/PUT/DELETE handlers needed -- all mutations happen via server actions in todoist, which call this GET endpoint to check access before proceeding.
  </action>
  <verify>
Run `npm run build` in /Users/dweinbeck/Documents/personal-brand. Run `npm run lint`. Run `npm test`. All pass.
  </verify>
  <done>
`GET /api/billing/tasks/access` route exists, authenticates via Bearer token, calls `checkTasksAccess()`, and returns `{ mode, reason, weekStart }` JSON. Build and lint pass.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes in personal-brand repo
2. `npm run lint` passes in personal-brand repo
3. `npm test` passes in personal-brand repo (existing tests, including tool pricing seed tests which now include tasks_app)
4. `grep -r "tasks_app" src/lib/billing/tools.ts` shows the new entry
5. `grep -r "checkTasksAccess" src/lib/billing/tasks.ts` shows the function
6. `ls src/app/api/billing/tasks/access/route.ts` confirms route exists
</verification>

<success_criteria>
- checkTasksAccess() mirrors checkEnvelopeAccess() logic with tasks_billing collection and tasks_app tool key
- GET /api/billing/tasks/access returns correct JSON for authenticated requests
- tasks_app tool pricing seed entry exists at 100 credits, active: true
- All quality gates pass (build, lint, test)
</success_criteria>

<output>
After completion, create `.planning/phases/34-weekly-credit-gating/34-01-SUMMARY.md`
</output>
