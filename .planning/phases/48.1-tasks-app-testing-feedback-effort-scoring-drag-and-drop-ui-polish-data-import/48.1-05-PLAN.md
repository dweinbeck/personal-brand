---
phase: 48.1-tasks-app-testing-feedback
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/actions/tasks/import.ts
  - src/app/apps/tasks/(authenticated)/page.tsx
autonomous: true
requirements: [TF-06]

must_haves:
  truths:
    - "Server action reads the import JSON and creates all records in the database"
    - "Workspace, projects, sections, tags, tasks, and subtasks are all created"
    - "Duplicate tasks are skipped (matching by name+deadlineAt within same project/section)"
    - "Import can be triggered from the Tasks welcome page"
    - "A summary is returned showing what was created and what was skipped"
  artifacts:
    - path: "src/actions/tasks/import.ts"
      provides: "Server action for bulk data import from JSON"
      contains: "importTasksAction"
  key_links:
    - from: "src/actions/tasks/import.ts"
      to: "prisma"
      via: "Prisma client for bulk record creation"
      pattern: "prisma\\.(workspace|project|section|task|tag)"
---

<objective>
Create a server action to import 30 tasks + 82 subtasks from the planning JSON file into the signed-in user's Tasks database, with duplicate detection and a summary report.

Purpose: The user has a 30-day focus sprint plan in JSON format that needs to be loaded into the Tasks app as real workspace/project/section/task records.
Output: A server action callable from the Tasks welcome page that bulk-imports the data.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/focus-sprint-30d.tasks-import.json
@src/actions/tasks/task.ts
@src/services/tasks/task.service.ts
@prisma/schema.prisma
@src/lib/prisma.ts
@src/lib/tasks/auth.ts
@src/app/apps/tasks/(authenticated)/page.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bulk import server action</name>
  <files>src/actions/tasks/import.ts</files>
  <action>
    Create `src/actions/tasks/import.ts` as a server action that imports data from the JSON file.

    ```ts
    "use server";

    import { readFile } from "node:fs/promises";
    import { join } from "node:path";
    import { revalidatePath } from "next/cache";
    import { prisma } from "@/lib/prisma";
    import { verifyUser } from "@/lib/tasks/auth";
    ```

    **Function: `importTasksAction(idToken: string)`**

    Steps:
    1. Verify user with `verifyUser(idToken)` — return error if unauthorized
    2. Read the JSON file from `.planning/focus-sprint-30d.tasks-import.json` using `readFile(join(process.cwd(), ".planning", "focus-sprint-30d.tasks-import.json"), "utf-8")`
    3. Parse the JSON and extract: `workspace.name`, `workspace.tagsToEnsure`, `workspace.projects`, `planItems`

    **Create/find workspace:**
    - Look for existing workspace with matching name + userId
    - If found, reuse it; if not, create it
    - Track: `workspaceCreated: boolean`

    **Create/find tags:**
    - For each tag in `workspace.tagsToEnsure`, use `prisma.tag.upsert` with `where: { userId_name: { userId, name: tag.name } }` and `create: { userId, name: tag.name, color: tag.color }`
    - Build a `tagMap: Record<string, string>` mapping tag name -> tag ID
    - Track: `tagsCreated: number`, `tagsExisting: number`

    **Create/find projects:**
    - For each project in `workspace.projects`, check if a project with the same name exists in the workspace
    - If not, create it: `prisma.project.create({ data: { workspaceId, name: project.name } })`
    - Build a `projectMap: Record<string, string>` mapping project name -> project ID
    - Track: `projectsCreated: number`, `projectsExisting: number`

    **Create/find sections:**
    - For each project, iterate its sections array
    - Check if section exists in that project by name
    - If not, create with incrementing order: `prisma.section.create({ data: { projectId, name: section, order: index } })`
    - Build a `sectionMap: Record<string, string>` mapping `${projectName}::${sectionName}` -> section ID
    - Track: `sectionsCreated: number`, `sectionsExisting: number`

    **Create tasks and subtasks:**
    - For each `planItem` in `planItems`:
      - Get the projectId from `projectMap[planItem.projectName]`
      - Get the sectionId from `sectionMap[planItem.projectName + "::" + planItem.sectionName]` (if sectionName exists)
      - **Duplicate check for parent task:** Look for existing task with same `name` AND `deadlineAt` within the same project/section for this userId. If found, skip.
      - Create parent task with: `{ userId, projectId, sectionId, name, description, deadlineAt (parse ISO string), effort, status: "OPEN", order }`
      - **Attach tags:** After creating the parent task, create TaskTag records for each tag in `planItem.task.tags` using the `tagMap`
      - For each subtask in `planItem.task.subtasks` (if any):
        - **Duplicate check for subtask:** Look for existing subtask with same name + parentTaskId
        - Create subtask: `{ userId, projectId, sectionId: null, parentTaskId: parentTask.id, name, description, deadlineAt, effort, status: "OPEN", order }`
      - Track: `tasksCreated`, `tasksSkipped`, `subtasksCreated`, `subtasksSkipped`

    4. Call `revalidatePath("/apps/tasks")`
    5. Return a summary object:
    ```ts
    return {
      success: true,
      summary: {
        workspace: { id: workspaceId, name: workspaceName, created: workspaceCreated },
        tags: { created: tagsCreated, existing: tagsExisting },
        projects: { created: projectsCreated, existing: projectsExisting },
        sections: { created: sectionsCreated, existing: sectionsExisting },
        tasks: { created: tasksCreated, skipped: tasksSkipped },
        subtasks: { created: subtasksCreated, skipped: subtasksSkipped },
      }
    };
    ```

    **Important edge cases:**
    - If `planItem.task.deadlineAt` is a date string like "2026-02-18", convert to `new Date(planItem.task.deadlineAt + "T00:00:00")` for timezone consistency
    - Handle the case where tags array might reference tags not in `tagsToEnsure` (skip silently)
    - Use try/catch around the entire import and return `{ error: message }` on failure
    - Process items sequentially (not Promise.all) to respect database order and avoid race conditions on duplicate checks
  </action>
  <verify>
    - `npm run lint` passes
    - `npm run build` passes
    - File exports `importTasksAction` function
    - Function reads JSON from filesystem
    - Function creates workspace, tags, projects, sections, tasks, subtasks
    - Function returns summary with counts
  </verify>
  <done>Server action can import all data from the JSON file into the signed-in user's database, with duplicate detection and a comprehensive summary report.</done>
</task>

<task type="auto">
  <name>Task 2: Add import button to Tasks welcome page</name>
  <files>src/app/apps/tasks/(authenticated)/page.tsx</files>
  <action>
    Add an "Import Sprint Plan" button to the Tasks welcome page that triggers the import action.

    The page is currently a server component. To add the import button (which needs client interaction), create a small client component inline or extract it.

    **Option: Add a client component `ImportButton` at the bottom of page.tsx or as a separate file.**

    Create a new file `src/app/apps/tasks/(authenticated)/import-button.tsx`:
    ```tsx
    "use client";

    import { useState } from "react";
    import { importTasksAction } from "@/actions/tasks/import";
    import { useAuth } from "@/context/AuthContext";

    export function ImportButton() {
      const { user } = useAuth();
      const [loading, setLoading] = useState(false);
      const [result, setResult] = useState<null | {
        success?: boolean;
        error?: string;
        summary?: {
          workspace: { id: string; name: string; created: boolean };
          tags: { created: number; existing: number };
          projects: { created: number; existing: number };
          sections: { created: number; existing: number };
          tasks: { created: number; skipped: number };
          subtasks: { created: number; skipped: number };
        };
      }>(null);

      async function handleImport() {
        if (!user) return;
        setLoading(true);
        const token = await user.getIdToken();
        const res = await importTasksAction(token);
        setResult(res);
        setLoading(false);
      }

      return (
        <div className="mt-6">
          {!result ? (
            <button
              type="button"
              onClick={handleImport}
              disabled={loading}
              className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-primary bg-gold-light rounded-[var(--radius-button)] hover:bg-gold/20 transition-colors cursor-pointer disabled:opacity-50"
            >
              {loading ? "Importing..." : "Import Sprint Plan"}
            </button>
          ) : result.error ? (
            <div className="rounded-xl border border-danger/20 bg-danger/5 p-4 text-sm text-danger">
              <p className="font-semibold">Import failed</p>
              <p className="mt-1">{result.error}</p>
            </div>
          ) : result.summary ? (
            <div className="rounded-xl border border-sage/20 bg-sage/5 p-4 text-sm text-text-primary">
              <p className="font-semibold text-sage mb-2">Import complete</p>
              <ul className="space-y-1 text-text-secondary">
                <li>Workspace: {result.summary.workspace.name} ({result.summary.workspace.created ? "created" : "existing"})</li>
                <li>Tags: {result.summary.tags.created} created, {result.summary.tags.existing} existing</li>
                <li>Projects: {result.summary.projects.created} created, {result.summary.projects.existing} existing</li>
                <li>Sections: {result.summary.sections.created} created, {result.summary.sections.existing} existing</li>
                <li>Tasks: {result.summary.tasks.created} created, {result.summary.tasks.skipped} skipped</li>
                <li>Subtasks: {result.summary.subtasks.created} created, {result.summary.subtasks.skipped} skipped</li>
              </ul>
            </div>
          ) : null}
        </div>
      );
    }
    ```

    Then in `src/app/apps/tasks/(authenticated)/page.tsx`, add:
    ```tsx
    import { ImportButton } from "./import-button";
    ```

    And render `<ImportButton />` below the KPI card area (inside the userId check so only authenticated users see it):
    ```tsx
    {kpiData && (
      <>
        <TasksKpiCard ... />
        <ImportButton />
      </>
    )}
    ```

    Also add the import-button.tsx to the files_modified list in the plan's action section tracking.
  </action>
  <verify>
    - `npm run lint` passes
    - `npm run build` passes
    - Import button renders on the Tasks welcome page for authenticated users
    - Clicking the button calls importTasksAction
    - Summary is displayed after import completes
  </verify>
  <done>Tasks welcome page has an "Import Sprint Plan" button that triggers the import action and displays a summary of what was created/skipped.</done>
</task>

</tasks>

<verification>
- `npm run lint && npm run build && npm test` — all pass
- Import action creates all records from the JSON
- Duplicate detection works (re-running import skips already-created tasks)
- Summary report shows accurate counts
</verification>

<success_criteria>
1. Server action reads JSON and creates workspace, 6 projects, sections, 17 tags, 30 tasks, 82 subtasks
2. Duplicate detection by name+deadlineAt prevents double-imports
3. Import button on welcome page triggers the action and shows results
4. All deadlines, efforts, tags, and descriptions are set correctly from JSON
5. Build, lint, and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/48.1-tasks-app-testing-feedback-effort-scoring-drag-and-drop-ui-polish-data-import/48.1-05-SUMMARY.md`
</output>
