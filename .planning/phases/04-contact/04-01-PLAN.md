---
phase: 04-contact
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/schemas/contact.ts
  - src/lib/firebase.ts
  - src/lib/actions/contact.ts
  - src/components/contact/SubmitButton.tsx
  - src/components/contact/ContactForm.tsx
autonomous: true

must_haves:
  truths:
    - "Visitor can fill out and submit a contact form with name, email, and message"
    - "Invalid submissions are rejected with clear error messages"
    - "Spam is blocked by honeypot and rate limiting"
    - "Successful form submissions are stored in Firestore"
  artifacts:
    - path: "src/lib/schemas/contact.ts"
      provides: "Zod validation schema for contact form"
      exports: ["contactSchema", "ContactFormData"]
    - path: "src/lib/firebase.ts"
      provides: "Firebase Admin singleton and Firestore write function"
      exports: ["db", "saveContactSubmission"]
    - path: "src/lib/actions/contact.ts"
      provides: "Server Action for form submission with validation, honeypot, rate limiting"
      exports: ["submitContact", "ContactState"]
    - path: "src/components/contact/SubmitButton.tsx"
      provides: "Submit button with pending state via useFormStatus"
      exports: ["SubmitButton"]
    - path: "src/components/contact/ContactForm.tsx"
      provides: "Client form component with useActionState"
      exports: ["ContactForm"]
  key_links:
    - from: "src/components/contact/ContactForm.tsx"
      to: "src/lib/actions/contact.ts"
      via: "useActionState(submitContact, initialState)"
      pattern: "useActionState\\(submitContact"
    - from: "src/lib/actions/contact.ts"
      to: "src/lib/schemas/contact.ts"
      via: "Zod safeParse validation"
      pattern: "contactSchema\\.safeParse"
    - from: "src/lib/actions/contact.ts"
      to: "src/lib/firebase.ts"
      via: "saveContactSubmission call"
      pattern: "saveContactSubmission"
    - from: "src/components/contact/SubmitButton.tsx"
      to: "ContactForm.tsx form"
      via: "useFormStatus (must be child of form)"
      pattern: "useFormStatus"
---

<objective>
Build the contact form with full server-side validation, spam protection, and Firestore storage.

Purpose: Implements CONT-01 (form with name/email/message), CONT-02 (validation + honeypot + rate limiting), CONT-03 (Firestore storage). This is the core functionality of the contact page.
Output: Working ContactForm component backed by a Server Action that validates with Zod, checks honeypot, rate-limits by IP, and writes to Firestore.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-contact/04-RESEARCH.md
@src/lib/github.ts
@src/app/layout.tsx
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create validation schema + Firebase layer</name>
  <files>
    package.json
    src/lib/schemas/contact.ts
    src/lib/firebase.ts
  </files>
  <action>
    1. Install zod and firebase-admin:
       ```
       npm install zod firebase-admin
       ```

    2. Create `src/lib/schemas/contact.ts`:
       - Export a Zod schema `contactSchema` with:
         - `name`: z.string().min(1, "Name is required").max(100, "Name is too long")
         - `email`: z.string().email("Please enter a valid email address")
         - `message`: z.string().min(10, "Message must be at least 10 characters").max(2000, "Message is too long")
       - Export `ContactFormData` type inferred from the schema

    3. Create `src/lib/firebase.ts`:
       - Use modular imports: `firebase-admin/app` and `firebase-admin/firestore`
       - Singleton pattern using `getApps().length > 0` check
       - Initialize with `cert()` using env vars: FIREBASE_PROJECT_ID, FIREBASE_CLIENT_EMAIL, FIREBASE_PRIVATE_KEY
       - IMPORTANT: Apply `.replace(/\\n/g, "\n")` to FIREBASE_PRIVATE_KEY for newline handling
       - Export `db` (Firestore instance)
       - Export `saveContactSubmission(data: ContactFormData)` that writes to "contact_submissions" collection with `createdAt: new Date().toISOString()`
       - Graceful handling: if Firebase env vars are missing, log a warning but do not crash the app at import time. The `saveContactSubmission` function should throw, which the Server Action catches.

    Run `npx biome check --write src/lib/schemas/contact.ts src/lib/firebase.ts` to fix any import ordering issues.
  </action>
  <verify>
    - `npm ls zod firebase-admin` shows both installed
    - `npx biome check src/lib/schemas/contact.ts src/lib/firebase.ts` passes with no errors
    - TypeScript: `npx tsc --noEmit` passes (or at least these files have no type errors)
  </verify>
  <done>
    Zod contact schema exports contactSchema and ContactFormData type. Firebase singleton exports db and saveContactSubmission. Both files pass Biome linting.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Server Action with spam protection and ContactForm client component</name>
  <files>
    src/lib/actions/contact.ts
    src/components/contact/SubmitButton.tsx
    src/components/contact/ContactForm.tsx
  </files>
  <action>
    1. Create `src/lib/actions/contact.ts`:
       - Add `"use server";` directive at top
       - Export `ContactState` type: `{ errors?: { name?: string[]; email?: string[]; message?: string[] }; message?: string; success?: boolean }`
       - Implement in-memory rate limiting:
         - Module-level `Map<string, number[]>` tracking submission timestamps per IP
         - Limit: 3 submissions per 15 minutes per IP
         - Extract IP from headers (x-forwarded-for or x-real-ip, fallback to "unknown")
         - Clean up old entries on each check
       - Export `submitContact(prevState: ContactState, formData: FormData): Promise<ContactState>`:
         1. Check honeypot field "company_website" -- if filled, return fake success `{ success: true, message: "Thank you for your message!" }`
         2. Check rate limit -- if exceeded, return `{ success: false, message: "Too many submissions. Please try again later." }`
         3. Parse form data and validate with `contactSchema.safeParse()` -- if invalid, return `{ errors: validatedFields.error.flatten().fieldErrors, success: false }`
         4. Call `saveContactSubmission(validatedFields.data)` -- if success, return `{ success: true, message: "Thank you for your message! I'll get back to you soon." }`
         5. Catch errors -- return `{ success: false, message: "Something went wrong. Please try again." }`
       - Import headers from "next/headers" for IP extraction

    2. Create `src/components/contact/SubmitButton.tsx`:
       - Add `"use client";` directive
       - Import `useFormStatus` from "react-dom"
       - Render a button with type="submit", disabled when pending
       - Show "Sending..." when pending, "Send Message" otherwise
       - Style: consistent with project (blue-600 bg, white text, rounded-md, hover:blue-700, disabled:opacity-50, transition-colors)

    3. Create `src/components/contact/ContactForm.tsx`:
       - Add `"use client";` directive
       - Import `useActionState` from "react" (NOT react-dom -- React 19 moved it)
       - Import `submitContact` and `ContactState` from "@/lib/actions/contact"
       - Import `SubmitButton` from "./SubmitButton"
       - Import `clsx` for conditional error styling
       - Use `useActionState(submitContact, initialState)` where initialState is `{}`
       - On success (state.success === true): render a green success message div with state.message
       - Form layout with `space-y-6`:
         a. Honeypot field: wrapped in `<div className="hidden" aria-hidden="true">` with label "Company Website", input name="company_website", tabIndex={-1}, autoComplete="off"
         b. Name field: label + text input, name="name", required attribute. Show `state.errors?.name?.[0]` in red text below if present.
         c. Email field: label + email input, name="email", required attribute. Show `state.errors?.email?.[0]` in red text below if present.
         d. Message field: label + textarea, name="message", rows={5}, required attribute. Show `state.errors?.message?.[0]` in red text below if present.
         e. General error message: if `state.message && !state.success`, show in red with `aria-live="polite"`
         f. SubmitButton component
       - Input styling: `mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 shadow-sm focus:border-blue-500 focus:ring-1 focus:ring-blue-500`
       - Error input styling: add `border-red-500` via clsx when field has errors
       - Label styling: `block text-sm font-medium text-gray-700`

    Run `npx biome check --write src/lib/actions/contact.ts src/components/contact/SubmitButton.tsx src/components/contact/ContactForm.tsx` after creating all files.
  </action>
  <verify>
    - `npx biome check src/lib/actions/ src/components/contact/` passes with no errors
    - `npx tsc --noEmit` passes
    - `npm run build` completes without errors (Server Action compiles, client components bundle correctly)
  </verify>
  <done>
    Server Action validates with Zod, checks honeypot, rate-limits by IP, and writes to Firestore. ContactForm renders with useActionState, shows field-level errors for invalid input, shows success message on submit. SubmitButton shows pending state. Build passes.
  </done>
</task>

</tasks>

<verification>
- `npm run build` succeeds (all new files compile without errors)
- `npx biome check src/lib/schemas/ src/lib/actions/ src/lib/firebase.ts src/components/contact/` reports no issues
- ContactForm.tsx imports submitContact via useActionState (not manual fetch)
- SubmitButton.tsx uses useFormStatus from react-dom (in separate component, not inline in form)
- Server Action includes honeypot check, rate limiting, Zod validation, and Firestore write -- in that order
- Honeypot field uses plausible name "company_website" with aria-hidden="true" and tabIndex={-1}
</verification>

<success_criteria>
- zod and firebase-admin are installed in package.json
- ContactForm component renders name, email, message fields with validation error display
- Server Action rejects invalid input with field-level Zod errors
- Honeypot field is hidden from users but catches bots
- Rate limiting blocks more than 3 submissions per 15 minutes per IP
- Successful submissions call saveContactSubmission to write to Firestore
- Build completes successfully
</success_criteria>

<output>
After completion, create `.planning/phases/04-contact/04-01-SUMMARY.md`
</output>
