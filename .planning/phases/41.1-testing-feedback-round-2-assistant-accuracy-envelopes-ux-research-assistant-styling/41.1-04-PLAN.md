---
phase: 41.1-testing-feedback-round-2-assistant-accuracy-envelopes-ux-research-assistant-styling
plan: 04
type: execute
wave: 2
depends_on: ["41.1-03"]
files_modified:
  - src/lib/hooks/use-research-chat.ts
  - src/components/tools/research-assistant/ResearchAssistantPage.tsx
  - src/app/api/tools/research-assistant/conversations/[id]/route.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "Clicking a sidebar conversation entry fully restores the original prompt, both model responses, and any follow-up exchanges"
    - "User can continue asking follow-up questions after loading a conversation as if they never left"
    - "When a conversation is loaded, the page scrolls to the bottom (latest exchange)"
  artifacts:
    - path: "src/app/api/tools/research-assistant/conversations/[id]/route.ts"
      provides: "GET endpoint that returns full conversation with messages"
    - path: "src/lib/hooks/use-research-chat.ts"
      provides: "loadConversation function that fetches and hydrates full conversation state"
    - path: "src/components/tools/research-assistant/ResearchAssistantPage.tsx"
      provides: "Conversation rendering from loaded state with follow-up capability"
  key_links:
    - from: "src/components/tools/research-assistant/ResearchAssistantPage.tsx"
      to: "use-research-chat.ts loadConversation"
      via: "loadConversation callback"
      pattern: "loadConversation"
    - from: "src/lib/hooks/use-research-chat.ts"
      to: "/api/tools/research-assistant/conversations/[id]"
      via: "fetch GET"
      pattern: "fetch.*conversations/"
    - from: "src/app/api/tools/research-assistant/conversations/[id]/route.ts"
      to: "conversation-store.ts loadConversation"
      via: "Firestore query"
      pattern: "loadConversation"
---

<objective>
Enable full conversation history loading in the Research Assistant: clicking a sidebar entry fetches the complete conversation from Firestore and restores all exchanges (prompt, responses, follow-ups) so the user can continue the conversation.

Purpose: Users currently see conversation titles in the sidebar but clicking them doesn't restore the full conversation state. This makes the conversation history feature functional.
Output: New API route for single conversation retrieval, updated hook for conversation hydration, updated page component for rendering loaded conversations.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41.1-testing-feedback-round-2-assistant-accuracy-envelopes-ux-research-assistant-styling/41.1-03-PLAN.md
@src/lib/hooks/use-research-chat.ts
@src/lib/research-assistant/conversation-store.ts
@src/lib/research-assistant/types.ts
@src/components/tools/research-assistant/ResearchAssistantPage.tsx
@src/app/api/tools/research-assistant/conversations/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GET /api/tools/research-assistant/conversations/[id] endpoint</name>
  <files>src/app/api/tools/research-assistant/conversations/[id]/route.ts</files>
  <action>
Create a new dynamic route that returns the full conversation with all messages:

1. **Create the directory and route file**: `src/app/api/tools/research-assistant/conversations/[id]/route.ts`

2. **Implement GET handler**:
   - Use `verifyUser` for auth (same pattern as the conversations list route).
   - Extract `id` from the route params.
   - Call `loadConversation(id)` from `@/lib/research-assistant/conversation-store`.
   - Verify `conversation.userId === auth.uid` (ownership check â€” return 403 if mismatch).
   - Return the conversation and messages as JSON:
     ```json
     {
       "conversation": { "id", "title", "tier", "messageCount", ... },
       "messages": [
         { "role": "user", "content": "...", "turnNumber": 0, "action": "prompt" },
         { "role": "gemini", "content": "...", "turnNumber": 1, ... },
         { "role": "openai", "content": "...", "turnNumber": 1, ... },
         ...
       ]
     }
     ```
   - Handle errors: 404 for not found, 500 for Firestore errors.
   - Serialize Firestore Timestamps to ISO strings for `createdAt` fields.

3. **Set runtime and dynamic exports** matching the conversations list route:
   ```ts
   export const runtime = "nodejs";
   export const dynamic = "force-dynamic";
   ```
  </action>
  <verify>npm run lint && npm run build</verify>
  <done>GET /api/tools/research-assistant/conversations/[id] returns full conversation document and ordered messages with ownership verification.</done>
</task>

<task type="auto">
  <name>Task 2: Implement full conversation loading in hook and page component</name>
  <files>
    src/lib/hooks/use-research-chat.ts
    src/components/tools/research-assistant/ResearchAssistantPage.tsx
  </files>
  <action>
**A. Upgrade loadConversation in use-research-chat.ts:**

Currently `loadConversation` just sets the conversation ID. Upgrade it to fetch the full conversation data and hydrate state:

1. Change `loadConversation` signature to accept `(id: string)` and make it async.
2. When `id` is a non-empty string:
   - Fetch `GET /api/tools/research-assistant/conversations/${id}` with auth token (use `getIdToken()`).
   - Parse the response JSON.
   - Group messages by their `turnNumber` and `action`:
     - Find the latest user message content (the prompt to display).
     - Find the latest gemini and openai responses (by highest turnNumber with matching roles).
     - Build `ResearchChatState` from the response messages:
       ```ts
       setState({
         gemini: { text: geminiText, status: "complete", error: undefined, usage: geminiUsage },
         openai: { text: openaiText, status: "complete", error: undefined, usage: openaiUsage },
         overallStatus: "complete",
       });
       ```
     - If reconsider messages exist (role `gemini-reconsider` / `openai-reconsider`), populate `reconsiderState` similarly.
   - Set `conversationId` to the loaded ID.
   - Set `tierRef.current` from the conversation's tier.

3. When `id` is empty string (new conversation):
   - Reset to `INITIAL_STATE` (current behavior).
   - Set `conversationId` to null.

4. Export a new `loadedPrompt` state variable (the prompt text from the loaded conversation) so the page can display it.

5. Export a `loadedExchanges` array that contains all prior exchanges from the loaded conversation (each exchange = { prompt, geminiText, openaiText, tier }). The page uses this to render the full conversation thread.

**B. Update ResearchAssistantPage to render loaded conversations:**

1. Destructure `loadedPrompt` and `loadedExchanges` from `useResearchChat`.

2. When a conversation is loaded (loadedExchanges is non-empty):
   - Render all loaded exchanges in order above the current response display.
   - Each exchange shows: the user's prompt text, then the ResponseDisplay for that exchange's gemini/openai state.
   - The current (most recent) exchange renders in the existing ResponseDisplay position.
   - Reconsider and FollowUp components still display based on the current state.

3. **Scroll to bottom on load**: After `loadConversation` resolves, scroll the main content area to the bottom. Use a `useEffect` that triggers on `conversationId` change:
   ```tsx
   useEffect(() => {
     if (conversationId) {
       // Small delay to let DOM render
       setTimeout(() => {
         const main = document.querySelector('main');
         if (main) main.scrollTop = main.scrollHeight;
       }, 100);
     }
   }, [conversationId]);
   ```

4. **Populate ChatInterface prompt**: When a conversation loads, show the original prompt in the ChatInterface input area (or above it as a non-editable display). The user should see what they originally asked.

5. **Merge with session history**: When a loaded conversation has follow-up exchanges, populate `sessionHistory` with those exchanges so the conversation thread (from plan 03) displays correctly. Alternatively, render `loadedExchanges` directly using the same layout pattern as the session history thread.

6. **Enable follow-up continuity**: After loading, the user should be able to type a follow-up in the FollowUpInput. The hook already supports `sendFollowUp` when `conversationId` is set, so this should work automatically once `conversationId` is set from the loaded conversation.
  </action>
  <verify>npm run lint && npm run build && npm test</verify>
  <done>Clicking a sidebar conversation entry fetches and displays the full conversation with all exchanges. User can continue asking follow-up questions. Page scrolls to the latest exchange on load.</done>
</task>

</tasks>

<verification>
1. `npm run lint` passes with zero errors
2. `npm run build` succeeds
3. `npm test` passes all tests
4. GET /api/tools/research-assistant/conversations/[id] returns full conversation
5. Clicking a sidebar entry restores the complete conversation thread
6. Follow-up questions work after loading a conversation
7. Page scrolls to bottom after loading
</verification>

<success_criteria>
- Sidebar conversation click fetches full conversation from Firestore
- All exchanges (prompt, responses, follow-ups) render in chronological order
- User can ask follow-up questions as if they never left
- Page scrolls to the latest exchange after loading
- Ownership check prevents loading other users' conversations
</success_criteria>

<output>
After completion, create `.planning/phases/41.1-testing-feedback-round-2-assistant-accuracy-envelopes-ux-research-assistant-styling/41.1-04-SUMMARY.md`
</output>
