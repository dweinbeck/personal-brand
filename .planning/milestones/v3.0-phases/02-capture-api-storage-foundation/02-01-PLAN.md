---
phase: 02-capture-api-storage-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/auth/api-key.ts
  - src/lib/gsd/schemas.ts
  - src/lib/gsd/capture.ts
  - src/lib/gsd/storage.ts
  - src/lib/env.ts
  - src/lib/firebase.ts
autonomous: true
requirements:
  - CAP-AUTH
  - CAP-ENV
  - CAP-SCHEMA
  - CAP-STORAGE

must_haves:
  truths:
    - "verifyApiKey returns authorized:true for correct X-API-Key header"
    - "verifyApiKey returns authorized:false with status 401 for missing or incorrect key"
    - "verifyApiKey returns authorized:false with status 503 when GSD_API_KEY env var is not set"
    - "API key comparison uses crypto.timingSafeEqual (not === operator)"
    - "saveCapture writes a document to gsd_captures collection with pending status"
    - "updateCaptureStatus updates status and updatedAt fields"
    - "uploadScreenshot saves a Buffer to Cloud Storage and returns gs:// path"
    - "All four new env vars (GSD_API_KEY, FIREBASE_STORAGE_BUCKET, GITHUB_PAT, DISCORD_WEBHOOK_URL) are optional in env schema"
    - "npm run dev does not crash when new env vars are unset"
    - "npm run build succeeds with zero type errors"
  artifacts:
    - path: "src/lib/auth/api-key.ts"
      provides: "API key auth middleware with constant-time comparison"
      exports: ["verifyApiKey", "apiKeyUnauthorizedResponse", "ApiKeyAuthResult"]
    - path: "src/lib/gsd/schemas.ts"
      provides: "Zod validation schemas for capture requests and document types"
      exports: ["dictationCaptureSchema", "captureStatusSchema", "captureDestinationSchema"]
    - path: "src/lib/gsd/capture.ts"
      provides: "Firestore persistence for gsd_captures collection"
      exports: ["saveCapture", "updateCaptureStatus", "CaptureInput"]
    - path: "src/lib/gsd/storage.ts"
      provides: "Cloud Storage upload utility for screenshot files"
      exports: ["uploadScreenshot"]
    - path: "src/lib/firebase.ts"
      provides: "Cloud Storage bucket export added"
      contains: "getStorage"
    - path: "src/lib/env.ts"
      provides: "Four new optional env vars in server schema"
      contains: "GSD_API_KEY"
  key_links:
    - from: "src/lib/auth/api-key.ts"
      to: "process.env.GSD_API_KEY"
      via: "runtime check at point of use"
      pattern: "process\\.env\\.GSD_API_KEY"
    - from: "src/lib/gsd/capture.ts"
      to: "src/lib/firebase.ts"
      via: "import db"
      pattern: "import.*db.*from.*firebase"
    - from: "src/lib/gsd/storage.ts"
      to: "src/lib/firebase.ts"
      via: "import storage"
      pattern: "import.*storage.*from.*firebase"
    - from: "src/lib/firebase.ts"
      to: "process.env.FIREBASE_STORAGE_BUCKET"
      via: "conditional bucket init"
      pattern: "getStorage.*bucket"
---

<objective>
Create the shared foundation modules for Phase 2: API key authentication middleware, Zod validation schemas, Firestore capture persistence, Cloud Storage upload utility, and env var registration. These modules are consumed by both capture endpoints (Plans 02-02 and 02-03).

Purpose: Establish all shared infrastructure before building the individual capture endpoints. Without these modules, neither endpoint can authenticate requests, validate input, persist captures, or upload files.

Output: Six files created/modified — four new modules in src/lib/ and two existing files updated.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-capture-api-storage-foundation/02-RESEARCH.md

# Existing patterns to follow
@src/lib/auth/admin.ts
@src/lib/auth/user.ts
@src/lib/env.ts
@src/lib/firebase.ts
@src/lib/brand-scraper/history.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API key auth middleware and env var registration</name>
  <files>
    src/lib/auth/api-key.ts
    src/lib/env.ts
  </files>
  <action>
    **1a. Create `src/lib/auth/api-key.ts`:**

    Follow the discriminated union pattern from `src/lib/auth/admin.ts`:

    - Export type `ApiKeyAuthResult = { authorized: true } | { authorized: false; error: string; status: 401 | 503 }`
    - Export function `verifyApiKey(request: Request): ApiKeyAuthResult` (synchronous — no async needed)
      - Read `process.env.GSD_API_KEY` at point of use (NOT via serverEnv() — matches firebase.ts pattern of direct process.env for module-scope-adjacent usage)
      - If `GSD_API_KEY` is not set: return `{ authorized: false, error: "GSD capture not configured.", status: 503 }`
      - Read `X-API-Key` header from request
      - If missing: return `{ authorized: false, error: "Missing X-API-Key header.", status: 401 }`
      - Compare using `crypto.timingSafeEqual` with SHA-256 hash normalization:
        ```
        import { timingSafeEqual, createHash } from "node:crypto";
        const providedHash = createHash("sha256").update(providedKey).digest();
        const expectedHash = createHash("sha256").update(expectedKey).digest();
        if (!timingSafeEqual(providedHash, expectedHash)) → 401
        ```
      - Hashing normalizes buffer lengths (timingSafeEqual throws on length mismatch)
      - On match: return `{ authorized: true }`
    - Export function `apiKeyUnauthorizedResponse(result: Extract<ApiKeyAuthResult, { authorized: false }>)` that returns `Response.json({ error: result.error }, { status: result.status })`

    **1b. Add four new optional env vars to `src/lib/env.ts`:**

    Add to `serverEnvBaseSchema` object (after the existing GOOGLE_GENERATIVE_AI_API_KEY entry):

    ```typescript
    // Builder OS capture API
    GSD_API_KEY: z
      .string()
      .min(1)
      .refine(isNotPlaceholder, "GSD_API_KEY looks like a placeholder")
      .optional(),

    FIREBASE_STORAGE_BUCKET: z
      .string()
      .min(1)
      .refine(isNotPlaceholder, "FIREBASE_STORAGE_BUCKET looks like a placeholder")
      .optional(),

    GITHUB_PAT: z
      .string()
      .min(1)
      .refine(isNotPlaceholder, "GITHUB_PAT looks like a placeholder")
      .refine(
        (val) => val.startsWith("ghp_") || val.startsWith("github_pat_"),
        "GITHUB_PAT must start with 'ghp_' or 'github_pat_'",
      )
      .optional(),

    DISCORD_WEBHOOK_URL: z
      .string()
      .url("DISCORD_WEBHOOK_URL must be a valid URL")
      .refine(
        (val) => val.includes("discord.com/api/webhooks/"),
        "DISCORD_WEBHOOK_URL must be a Discord webhook URL",
      )
      .optional(),
    ```

    Also add the four vars to both the `serverEnv()` function and the `validateServerEnv()` function parse calls, using `optionalEnv()` wrapper for secrets:

    ```typescript
    GSD_API_KEY: optionalEnv(process.env.GSD_API_KEY),
    FIREBASE_STORAGE_BUCKET: optionalEnv(process.env.FIREBASE_STORAGE_BUCKET),
    GITHUB_PAT: optionalEnv(process.env.GITHUB_PAT),
    DISCORD_WEBHOOK_URL: optionalEnv(process.env.DISCORD_WEBHOOK_URL),
    ```

    CRITICAL: All four MUST be `.optional()`. Do NOT make any of them required. This protects existing dev workflows.
  </action>
  <verify>
    1. `npm run build` succeeds (type check passes with new exports)
    2. `npm run lint` passes (no Biome errors)
    3. Verify api-key.ts imports `timingSafeEqual` and `createHash` from `node:crypto`
    4. Verify env.ts has all four new vars as `.optional()` in the schema AND in both parse call sites
  </verify>
  <done>
    - verifyApiKey returns authorized:true for correct key, authorized:false for wrong/missing key, and status 503 when GSD_API_KEY is unset
    - All four env vars are optional in schema and included in both serverEnv() and validateServerEnv() parse calls
    - No existing functionality is broken (all tests pass, build succeeds)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Firestore capture persistence, Cloud Storage upload, and Zod schemas</name>
  <files>
    src/lib/gsd/schemas.ts
    src/lib/gsd/capture.ts
    src/lib/gsd/storage.ts
    src/lib/firebase.ts
  </files>
  <action>
    **2a. Create `src/lib/gsd/schemas.ts`:**

    Use `import { z } from "zod"` (application schemas use zod, NOT zod/v4 — only env.ts uses zod/v4).

    Export:
    - `dictationCaptureSchema` — z.object with:
      - `transcript`: z.string().min(1, "Transcript is required").max(10_000, "Transcript too long (10,000 char max)")
      - `context`: z.string().max(2_000, "Context too long").optional()
    - `DictationCaptureRequest` type alias: `z.infer<typeof dictationCaptureSchema>`
    - `screenshotCaptureSchema` — z.object with:
      - `context`: z.string().max(2_000, "Context too long").optional()
    - `ScreenshotCaptureRequest` type alias
    - `captureStatusSchema` — z.enum(["pending", "processing", "routed", "failed"])
    - `CaptureStatus` type alias
    - `captureDestinationSchema` — z.enum(["github_issue", "task", "inbox"])
    - `CaptureDestination` type alias

    **2b. Create `src/lib/gsd/capture.ts`:**

    Follow the pattern from `src/lib/brand-scraper/history.ts` exactly:

    - Import `{ FieldValue } from "firebase-admin/firestore"` and `{ db } from "@/lib/firebase"`
    - `requireDb()` helper throws "Firestore not available." if db is undefined
    - `capturesCol()` returns `requireDb().collection("gsd_captures")`
    - Export interface `CaptureInput`:
      - `id: string`
      - `type: "dictation" | "screenshot"`
      - `transcript?: string`
      - `screenshotUrl?: string`
      - `context?: string`
    - Export async function `saveCapture(input: CaptureInput): Promise<void>`:
      - `const now = FieldValue.serverTimestamp()`
      - `capturesCol().doc(input.id).set({ ...input, status: "pending", routingResult: null, destination: null, destinationRef: null, error: null, createdAt: now, updatedAt: now })`
    - Export async function `updateCaptureStatus(id: string, update: { status: "processing" | "routed" | "failed"; routingResult?: Record<string, unknown>; destination?: string; destinationRef?: string; error?: string }): Promise<void>`:
      - `capturesCol().doc(id).update({ ...update, updatedAt: FieldValue.serverTimestamp() })`

    **2c. Create `src/lib/gsd/storage.ts`:**

    - Import `{ storage } from "@/lib/firebase"` (will be added in 2d)
    - Export async function `uploadScreenshot(captureId: string, buffer: Buffer, contentType: string): Promise<string>`:
      - If `!storage` throw `new Error("Cloud Storage not configured. Set FIREBASE_STORAGE_BUCKET.")`
      - Determine extension: `contentType.includes("png") ? "png" : contentType.includes("heic") ? "heic" : "jpg"`
      - `const filePath = \`gsd-captures/${captureId}/screenshot.${extension}\``
      - `const file = storage.file(filePath)`
      - `await file.save(buffer, { metadata: { contentType } })`
      - Return `\`gs://${storage.name}/${filePath}\``

    **2d. Modify `src/lib/firebase.ts`:**

    Add Cloud Storage export. Add import at top:
    ```typescript
    import { getStorage } from "firebase-admin/storage";
    ```

    Add after the `auth` export:
    ```typescript
    const storageBucket = process.env.FIREBASE_STORAGE_BUCKET;
    export const storage = app && storageBucket
      ? getStorage(app).bucket(storageBucket)
      : undefined;
    ```

    This follows the same conditional init pattern as `db` and `auth` — returns undefined when not configured, no crash.
  </action>
  <verify>
    1. `npm run build` succeeds (all new exports resolve, types valid)
    2. `npm run lint` passes
    3. Verify schemas.ts uses `import { z } from "zod"` (NOT zod/v4)
    4. Verify capture.ts follows the historyCol() / requireDb() pattern from brand-scraper/history.ts
    5. Verify firebase.ts conditionally exports `storage` (undefined when FIREBASE_STORAGE_BUCKET not set)
    6. `npm test` passes (existing tests not broken)
  </verify>
  <done>
    - Three new modules created in src/lib/gsd/ with correct imports and exports
    - firebase.ts exports `storage` conditionally (no crash when env var missing)
    - All schemas use zod (not zod/v4)
    - Firestore persistence uses FieldValue.serverTimestamp() and follows requireDb() pattern
    - Cloud Storage upload returns gs:// path format
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` — zero errors
2. `npm run build` — zero errors, all new modules type-check
3. `npm test` — all existing tests pass (no regression)
4. Manual check: `src/lib/env.ts` has four new `.optional()` vars in schema, serverEnv(), and validateServerEnv()
5. Manual check: `src/lib/firebase.ts` exports `storage` conditionally
6. Manual check: `src/lib/auth/api-key.ts` uses `timingSafeEqual` (not `===`) for key comparison
</verification>

<success_criteria>
- Six files created/modified as specified
- API key auth middleware uses constant-time comparison
- All env vars are optional (npm run dev doesn't crash without them)
- Firestore capture module follows established patterns (requireDb, collection helper, FieldValue.serverTimestamp)
- Cloud Storage module conditionally initializes (returns undefined when bucket not configured)
- Build, lint, and test all pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-capture-api-storage-foundation/02-01-SUMMARY.md`
</output>
