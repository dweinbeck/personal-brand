---
phase: 06-wire-reroute-destination-handlers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/admin/builder-inbox/[id]/reroute/route.ts
  - src/lib/gsd/__tests__/reroute-route.test.ts
autonomous: true
requirements:
  - INBOX-REROUTE

must_haves:
  truths:
    - "Admin can reroute a capture to GitHub and a real GitHub issue is created"
    - "Admin can reroute a capture to Tasks and a real task is created"
    - "Admin can reroute a capture to Inbox and only Firestore status is updated (no handler call)"
    - "If destination handler fails, the capture is marked as failed with the error message"
    - "Admin sees the real destinationRef (issue URL or task ID) in the API response, not a manual: prefix"
    - "Discord alerts fire on successful reroute and on failure"
  artifacts:
    - path: "src/app/api/admin/builder-inbox/[id]/reroute/route.ts"
      provides: "Reroute endpoint that executes destination handlers"
      contains: "routeToGitHub|routeToTask"
    - path: "src/lib/gsd/__tests__/reroute-route.test.ts"
      provides: "Unit tests for reroute endpoint"
      contains: "describe.*reroute"
  key_links:
    - from: "src/app/api/admin/builder-inbox/[id]/reroute/route.ts"
      to: "src/lib/gsd/destinations/github.ts"
      via: "dynamic import of routeToGitHub"
      pattern: "import.*destinations/github"
    - from: "src/app/api/admin/builder-inbox/[id]/reroute/route.ts"
      to: "src/lib/gsd/destinations/tasks.ts"
      via: "dynamic import of routeToTask"
      pattern: "import.*destinations/tasks"
    - from: "src/app/api/admin/builder-inbox/[id]/reroute/route.ts"
      to: "src/lib/gsd/capture.ts"
      via: "getCapture to load capture data before routing"
      pattern: "getCapture"
    - from: "src/app/api/admin/builder-inbox/[id]/reroute/route.ts"
      to: "src/lib/gsd/discord.ts"
      via: "fire-and-forget Discord alerts"
      pattern: "alertCaptureRouted|alertCaptureFailed"
---

<objective>
Wire the reroute endpoint to actually execute destination handlers (routeToGitHub/routeToTask) instead of only marking Firestore status. Add proper error handling and Discord alerts.

Purpose: Completes the manual re-route flow end-to-end. Currently, when an admin clicks "Route to GitHub" in the Builder Inbox detail view, only a Firestore status flag is set — no GitHub issue or task is actually created. This fix closes that gap.

Output: A working reroute endpoint that creates real GitHub issues / tasks when an admin manually routes a capture, plus comprehensive unit tests.
</objective>

<execution_context>
@/Users/dweinbeck/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dweinbeck/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-wire-reroute-destination-handlers/06-RESEARCH.md

# Source files to modify/reference
@src/app/api/admin/builder-inbox/[id]/reroute/route.ts
@src/lib/gsd/router.ts
@src/lib/gsd/capture.ts
@src/lib/gsd/schemas.ts
@src/lib/gsd/destinations/github.ts
@src/lib/gsd/destinations/tasks.ts
@src/lib/gsd/discord.ts
@src/lib/gsd/__tests__/capture-route.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire destination handlers and error handling into reroute endpoint</name>
  <files>src/app/api/admin/builder-inbox/[id]/reroute/route.ts</files>
  <action>
Rewrite the POST handler in `src/app/api/admin/builder-inbox/[id]/reroute/route.ts` to actually execute destination handlers. Follow the proven pattern from `router.ts::routeToDestination()`.

**Imports to add:**
- `getCapture` from `@/lib/gsd/capture` (already imports `updateCaptureStatus`)
- `alertCaptureRouted`, `alertCaptureFailed` from `@/lib/gsd/discord`
- `type RoutingOutput, type RoutingCategory` from `@/lib/gsd/schemas`

**Flow changes (replace the current `updateCaptureStatus` call with this flow):**

1. Call `getCapture(id)` to load the full capture document. If `null`, return 404 `{ error: "Capture not found." }`.

2. Build a `RoutingOutput` for the destination handler:
   - If `capture.routingResult` exists (prior LLM classification), spread it and override `category` with the admin's chosen `destination`.
   - If `capture.routingResult` is missing (capture never classified or classification failed), construct a minimal `RoutingOutput` from raw capture data:
     - `category`: the destination param cast as `RoutingCategory`
     - `title`: use `capture.transcript?.slice(0, 100)` or `capture.context?.slice(0, 100)` or `"Manual reroute"`
     - `summary`: use `capture.transcript` or `capture.context` or `"Manually rerouted from Builder Inbox"`
     - `priority`: `"medium"`
     - `confidence`: `1.0` (manual = full confidence)

3. Wrap the destination execution in try/catch:
   - **In the try block:**
     - Switch on `parsed.data.destination`:
       - `"github_issue"`: Dynamic import `routeToGitHub` from `@/lib/gsd/destinations/github`, call it with the routing output, get `issueUrl`.
       - `"task"`: Dynamic import `routeToTask` from `@/lib/gsd/destinations/tasks`, call it with the routing output, get `taskId`.
       - `"inbox"`: No handler needed, set `destinationRef = "inbox"`.
     - Call `updateCaptureStatus(id, { status: "routed", destination, destinationRef })` with the REAL ref (issue URL or task ID), not the `manual:` prefix.
     - Fire-and-forget `alertCaptureRouted({ type: capture.type, destination, title: routingOutput.title, confidence: routingOutput.confidence })`.
     - Return 200 `{ status: "rerouted", id, destination, destinationRef }`.
   - **In the catch block:**
     - Extract error message: `err instanceof Error ? err.message : "Unknown error"`.
     - Call `updateCaptureStatus(id, { status: "failed", error: errorMessage })`.
     - Fire-and-forget `alertCaptureFailed({ type: capture.type ?? "unknown", error: errorMessage, captureId: id })`.
     - Return 500 `{ error: errorMessage }`.

**Do NOT:**
- Re-run LLM classification. The admin already chose the destination.
- Use fire-and-forget for the destination handler call. This is a synchronous admin action — await the result.
- Leave `routingResult` unchanged in Firestore. It's the historical LLM classification record. Only update `destination` and `destinationRef`.

**Expected result:** ~70-80 lines, up from 44.
  </action>
  <verify>
`npm run lint` passes with no errors on the modified file. `npm run build` compiles without type errors. Manual read of the file confirms destination handlers are imported and called.
  </verify>
  <done>
The reroute endpoint imports and calls `routeToGitHub`/`routeToTask` based on the destination parameter, uses `getCapture` to load capture data, constructs a valid `RoutingOutput`, handles errors by marking captures as failed, and sends Discord alerts on success/failure.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for the reroute endpoint</name>
  <files>src/lib/gsd/__tests__/reroute-route.test.ts</files>
  <action>
Create `src/lib/gsd/__tests__/reroute-route.test.ts` following the exact mock pattern from `capture-route.test.ts`.

**Mocks (before imports):**
- `vi.mock("@/lib/auth/admin")` — mock `verifyAdmin` and `unauthorizedResponse`
- `vi.mock("@/lib/gsd/capture")` — mock `getCapture` and `updateCaptureStatus`
- `vi.mock("@/lib/gsd/destinations/github")` — mock `routeToGitHub`
- `vi.mock("@/lib/gsd/destinations/tasks")` — mock `routeToTask`
- `vi.mock("@/lib/gsd/discord")` — mock `alertCaptureRouted` and `alertCaptureFailed`

**Imports:**
- `POST` from `@/app/api/admin/builder-inbox/[id]/reroute/route`
- All mocked modules

**Helper:**
- `makeRequest(body, id)`: Creates a `Request` object for `POST /api/admin/builder-inbox/{id}/reroute` with JSON body. Must handle the Next.js dynamic route `params: Promise<{ id: string }>` format — the test calls `POST(request, { params: Promise.resolve({ id }) })`.
- `makeCaptureDoc(overrides)`: Returns a default capture document shape (`{ id, type: "dictation", transcript: "Fix the login bug", status: "routed", routingResult: { category: "inbox", title: "Fix login bug", summary: "...", priority: "medium", confidence: 0.8 } }`).

**Test cases (describe block: "POST /api/admin/builder-inbox/[id]/reroute"):**

1. **Successful reroute to GitHub:** `getCapture` returns a capture with `routingResult`. `routeToGitHub` returns `"https://github.com/owner/repo/issues/42"`. Assert: response 200, `destinationRef` is the issue URL, `updateCaptureStatus` called with `status: "routed"` and the real URL, `alertCaptureRouted` called, `routeToGitHub` received a `RoutingOutput` with `category: "github_issue"`.

2. **Successful reroute to Tasks:** `routeToTask` returns `"task-id-123"`. Assert: response 200, `destinationRef` is the task ID, `routeToTask` called.

3. **Reroute to Inbox (no handler):** Destination is `"inbox"`. Assert: response 200, `destinationRef` is `"inbox"`, neither `routeToGitHub` nor `routeToTask` called, `updateCaptureStatus` called with `destination: "inbox"`.

4. **Capture not found (404):** `getCapture` returns `null`. Assert: response 404, `{ error: "Capture not found." }`, no destination handler called, no status update.

5. **Destination handler failure (500):** `routeToGitHub` throws `new Error("GITHUB_PAT not configured")`. Assert: response 500, `{ error: "GITHUB_PAT not configured" }`, `updateCaptureStatus` called with `status: "failed"` and the error message, `alertCaptureFailed` called.

6. **Missing routingResult fallback:** `getCapture` returns a capture WITHOUT `routingResult` (only `transcript`). `routeToGitHub` returns an issue URL. Assert: response 200, `routeToGitHub` received a `RoutingOutput` with `title` derived from `transcript`, `confidence: 1.0`, `priority: "medium"`.

7. **Unauthorized (401):** `verifyAdmin` returns `{ authorized: false }`. Assert: `unauthorizedResponse` called, no destination handler called.

8. **Invalid JSON body (400):** Request body is not valid JSON. Assert: response 400, `{ error: "Invalid JSON." }`.

9. **Invalid destination (400):** Body has `{ destination: "email" }` (not in enum). Assert: response 400 with validation error.

**beforeEach:** Clear all mocks, set defaults: `verifyAdmin` returns `{ authorized: true }`, `getCapture` returns `makeCaptureDoc()`, `routeToGitHub` returns a URL, `routeToTask` returns a task ID, `updateCaptureStatus` resolves, alert functions resolve.

**Expected result:** ~150-180 lines covering all branches.
  </action>
  <verify>
`npm test` passes with all reroute tests green. `npm run lint` passes. No test uses real Firestore, GitHub, or Discord — all dependencies are mocked.
  </verify>
  <done>
9 test cases cover: successful reroute to each destination (GitHub, Tasks, Inbox), capture not found, destination handler failure, missing routingResult fallback, unauthorized access, invalid JSON, and invalid destination. All pass green.
  </done>
</task>

</tasks>

<verification>
1. `npm run lint` — zero errors
2. `npm run build` — compiles without type errors
3. `npm test` — all tests pass, including the new reroute tests
4. Manual code review: `route.ts` imports and calls `routeToGitHub`/`routeToTask`, handles errors, sends Discord alerts
5. Grep confirms no `manual:` prefix in the destinationRef construction
</verification>

<success_criteria>
- The reroute endpoint calls `routeToGitHub` when destination is `github_issue` and returns the real issue URL
- The reroute endpoint calls `routeToTask` when destination is `task` and returns the real task ID
- The reroute endpoint just updates Firestore when destination is `inbox` (no handler needed)
- Destination handler failures result in 500 response with error message, capture marked as `failed`, Discord alert sent
- Captures without `routingResult` (never classified) still work — a minimal RoutingOutput is constructed from raw capture data
- 9 unit tests pass covering all branches
- `npm run lint && npm run build && npm test` all pass clean
</success_criteria>

<output>
After completion, create `.planning/phases/06-wire-reroute-destination-handlers/06-01-SUMMARY.md`
</output>
